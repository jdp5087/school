
;; terms needed for each package:

;; FIRST-TERM, REST-TERMS, EMPTY-TERMLIST?, THE-EMPTY-TERMLIST, ADJOIN-TERM, MAX-ORDER
;; CARDINALITY, DENSE-REPR, SPARSE-REPR, NEGATE, POLY-ZER0

;; DECIDE WHETHER MAPS AND ACCUMULATES ARE A GOOD IDEA, OR WHETHER IT IS BETTER TO JUST USE
;; SELECTORS AND RECURSE (SEE POLY ZERO FOR EXAMPLE), THIS MIGHT BE POSSIBLE TO INSTALL
;; IN POLYNOMIAL PACKAGE, SEE IF THE SAME IS TRUE FOR NEGATE THROUGH SELECTORS

(define (first-term terms)
  (apply-generic 'first-term terms))
(define (rest-terms terms)
  (apply-generic 'rest-terms terms))
(define (empty-termlist? terms)
  (apply-generic 'empty-termlist? terms))
(define (the-empty-termlist type)
  ((get 'the-empty-termlist 'type)))
(define (order term) (car term))
(define (coeff term) (cadr term))
(define (adjoin-term term terms)
  ((get 'adjoin-term (type-tag terms)) term (contents terms)))
(define (max-order terms)
  (apply-generic 'max-order terms))
(define (cardinality terms)
  (apply-generic 'cardinality terms))
(define (dense-repr terms)
  (apply-generic 'dense-repr terms))
(define (sparse-repr terms)
  (apply-generic 'sparse-repr terms))




(define (install-polynomial-package)

  ;;; REDEFINE THESE TERMS SO THAT THEY MAKE A CHOICE OF WHICH REPRESENTATION TO ADJOIN-TERM TO
  ;;; IN OTHER WORDS, DEFINE A PREDICATE TO DETERMINE WHICH REPRESENTATION IS BEST
  ;;; THIS COULD BE SOLVED BY ONLY MAKING RESULTS IN SPARSE FORM, BUT THEN CHECKING TO SEE
  ;;; IF THE POLYNOMIAL IS "DENSE" AFTER THE OPERATION HAS COMPLETED. OR VICE VERSA


  ;;; Need generic procedures max-order, num-terms, dense-repr, sparse-repr

  ;;; Need local poly-zero, neg

  (define (dense-poly? term-list)
    (if (<= (max-order terms) (* (cardinality terms) 1.5))
	true
	false))
  (define (choose-repr term-list)
    (if (dense-poly? term-list)
	(dense-repr term-list)
	(sparse-repr term-list)))
  (define (add-poly p1 p2)
    (if (same-variable? (variable p1) (variable p2))
	(let ((added-terms (add-terms (term-list p1)
				      (term-list p2))))
	  (make-poly (variable p1) (choose-repr added-terms)))
	(error "Polys not in same var -- ADD-POLY"
	       (list p1 p2))))
  (define (mul-poly p1 p2)
    (if (same-variable? (variable p1) (variable p2))
	(let ((multiplied-terms (mul-terms (term-list p1)
					   (term-list p2))))
	  (make-poly (variable p1) (choose-repr multiplied-terms)))
	(error "Polys not in same var -- MUL-POLY"
	       (list p1 p2))))
  (define (add-terms L1 L2)
    (cond ((empty-termlist? L1) L2)
	  ((empty-termlist? L2) L1)
	  (else
	   (let ((t1 (first-term L1)) (t2 (first-term L2)))
	     (cond ((> (order t1) (order t2))
		    (adjoin-term
		     t1 (add-terms (rest-terms L1) L2)))
		   ((< (order t1) (order t2))
		    (adjoin-term
		     t2 (add-terms L1 (rest-terms L2))))
		   (else
		    (adjoin-term
		     (make-term (order t1)
				(add (coeff t1) (coeff t2)))
		     (add-terms (rest-terms L1)
				(rest-terms L2)))))))))
  (define (mul-terms L1 L2)
    (if (empty-termlist? L1)
	(the-empty-termlist 'sparse)
	(add-terms (mul-term-by-all-terms (first-term L1) L2)
		   (mul-terms (rest-terms L1) L2))))
  (define (mul-term-by-all-terms t1 L)
    (if (empty-termlist? L)
	(the-empty-termlist 'sparse)
	(let ((t2 (first-term L)))
	  (adjoin-term
	   (make-term (+ (order t1) (order t2))
		      (mul (coeff t1) (coeff t2)))
	   (mul-term-by-all-terms t1 (rest-terms L))))))
  (define (make-poly var terms) (cons var terms))
  (define (variable p) (car p))
  (define (term-list p) (cdr p))
  (define (variable? x) (symbol? x))
  (define (same-variable? v1 v2)
    (and (variable? v1) (variable? v2) (eq? v1 v2)))
  (define (tag p) (attach-tag 'polynomial p))

  ;; interface to system

  (put 'add '(polynomial polynomial) (lambda (p1 p2) (tag (add-poly p1 p2))))
  (put 'sub '(polynomial polynomial) (lambda (p1 p2) (tag (add-poly p1 (negate p2)))))
  (put 'mul '(polynomial polynomial) (lambda (p1 p2) (tag (mul-poly p1 p2))))
  (put 'make 'polynomial (lambda (var terms) (tag (make-poly var terms))))
  (put 'negate '(polynomial) (lambda (p) (tag (neg p))))
  (put 'zero '(polynomial) (lambda (p) (tag (poly-zero? p))))
  'done)
  
  


