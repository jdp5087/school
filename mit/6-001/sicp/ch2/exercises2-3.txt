###2.53###
PROMPT:
------------------------------------------------------------
Exercise 2.53.  What would the interpreter print in response to evaluating each of the following expressions?
------------------------------------------------------------

(define (memq item x)
  (cond ((null? x) false)
        ((eq? item (car x)) x)
        (else (memq item (cdr x)))))

(list 'a 'b 'c)
;;(a b c)

(list (list 'george))
;; ((george))

(cdr '((x1 x2) (y1 y2)))
;;((y1 y2))  ;; tricky if you rush this one

(cadr '((x1 x2) (y1 y2)))
;;(y1 y2)

(pair? (car '(a short list)))
;;#f

(memq 'red '((red shoes) (blue socks)))
;;#f

(memq 'red '(red shoes blue socks))
;;(red shoes blue socks)

###2.54###
PROMPT:
------------------------------------------------------------
Exercise 2.54.  Two lists are said to be equal? if they contain equal elements arranged in the same order. For example,

(equal? '(this is a list) '(this is a list))

is true, but

(equal? '(this is a list) '(this (is a) list))

is false. To be more precise, we can define equal? recursively in terms of the basic eq? equality of symbols by saying that a and b are equal? if they are both symbols and the symbols are eq?, or if they are both lists such that (car a) is equal? to (car b) and (cdr a) is equal? to (cdr b). Using this idea, implement equal? as a procedure
------------------------------------------------------------

(define (my-equal? a b)
  (cond ((and (null? a) (null? b)) true)
	((and (list? (car a)) (list? (car b))) (my-equal? (car a) (car b)))
	((and (number? (car a)) (number? (car b)) (= (car a) (car b))) (my-equal? (cdr a) (cdr b)))
	((and (symbol? (car a)) (symbol? (car b)) (eq? (car a) (car b))) (my-equal? (cdr a) (cdr b)))
	(else false)))

(my-equal? '(1 2 '(a b)) '(1 2 '(a b)))
;Value: #t

(my-equal? '(1 2 '(a b)) '(1 2 '(a c)))
;Value: #f

###2.55###
PROMPT:
------------------------------------------------------------
Exercise 2.55.  Eva Lu Ator types to the interpreter the expression

(car ''abracadabra)

To her surprise, the interpreter prints back quote. Explain.
------------------------------------------------------------

(car ''abracadabra)
;Value: quote

My best explanation of this is by looking at:

''abracadabra
;Value 22: (quote abracadabra)


It appears that we have quoted a symbol that would have been interpreted by the evaluator
by applying quote to abracadabra. We are seeing the data structure as the interpreter would, before evaluation.

A better way of putting this might be to say that we are seeing the symbolic representation of a symbolic representation
in the interpreter. This is confirmed by looking at:

'''abracadabra
;Value 25: (quote (quote abracadabra))

###2.56###
PROMPT:
------------------------------------------------------------
Exercise 2.56.  Show how to extend the basic differentiator to handle more kinds of expressions. For instance, implement the differentiation rule


by adding a new clause to the deriv program and defining appropriate procedures exponentiation?, base, exponent, and make-exponentiation. (You may use the symbol ** to denote exponentiation.) Build in the rules that anything raised to the power 0 is 1 and anything raised to the power 1 is the thing itself.
------------------------------------------------------------

(define (deriv exp var)
  (cond ((number? exp) 0)
        ((variable? exp)
         (if (same-variable? exp var) 1 0))
        ((sum? exp)
         (make-sum (deriv (addend exp) var)
                   (deriv (augend exp) var)))
        ((product? exp)
         (make-sum
           (make-product (multiplier exp)
                         (deriv (multiplicand exp) var))
           (make-product (deriv (multiplier exp) var)
                         (multiplicand exp))))
	((exponentiation? exp)
	 (make-product (make-product (exponent exp)
				     (make-exponentiation (base exp) (- (exponent exp) 1)))
		       (deriv (base exp) var)))
        (else
         (error "unknown expression type -- DERIV" exp))))

(define (variable? x) (symbol? x))

(define (same-variable? v1 v2)
  (and (variable? v1) (variable? v2) (eq? v1 v2)))

(define (sum? x)
  (and (pair? x) (eq? (car x) '+)))

(define (addend s) (cadr s))

(define (augend s) (caddr s))

(define (product? x)
  (and (pair? x) (eq? (car x) '*)))

(define (multiplier p) (cadr p))

(define (multiplicand p) (caddr p))

(define (make-sum a1 a2)
  (cond ((=number? a1 0) a2)
        ((=number? a2 0) a1)
        ((and (number? a1) (number? a2)) (+ a1 a2))
        (else (list '+ a1 a2))))

(define (=number? exp num)
  (and (number? exp) (= exp num)))

(define (make-product m1 m2)
  (cond ((or (=number? m1 0) (=number? m2 0)) 0)
        ((=number? m1 1) m2)
        ((=number? m2 1) m1)
        ((and (number? m1) (number? m2)) (* m1 m2))
        (else (list '* m1 m2))))

(define (exponentiation? x)
  (and (pair? x) (eq? (car x) '**)))

(define (base x)
  (cadr x))
(define (exponent x)
  (caddr x))
(define (make-exponentiation base exp)
  (cond ((=number? exp 0) 1)
	((=number? exp 1) base)
	(else (list '** base exp))))



(deriv '(** x 3) 'x)
;Value 28: (* 3 (** x 2))


###2.57###
PROMPT:
------------------------------------------------------------
Exercise 2.57.  Extend the differentiation program to handle sums and products of arbitrary numbers of (two or more) terms. Then the last example above could be expressed as

(deriv '(* x y (+ x 3)) 'x)

Try to do this by changing only the representation for sums and products, without changing the deriv procedure at all. For example, the addend of a sum would be the first term, and the augend would be the sum of the rest of the terms.
------------------------------------------------------------
(define (make-sum addend . rest)
  (let ((sum (accumulate (lambda (x y)
			   (cond ((=number? x 0) y)
				 ((and (not (null? y)) (number? x) (number? (car y))) (cons (+ x (car y)) (cdr y)))
				 (else (cons x y))))
			 '()
			 (append (list addend) rest))))
    (if (= (length sum) 1)
	(car sum)
	(cons '+ sum))))

(define (make-product multiplicand . rest)
  (define (zeros? seq)
    (define (zeros-iter seq)
      (cond ((null? seq) false)
	    ((=number? (car seq) 0) true)
	    (else (zeros-iter (cdr seq)))))
    (zeros-iter seq))
  (let ((product 
	 (accumulate (lambda (x y)
		       (cond ((or (=number? x 0) (=number? y 0)) (cons 0 '()))
			     ((=number? x 1) y)
			     ((and (not (null? y)) (number? x) (number? (car y))) (cons (* x (car y)) (cdr y)))
			     (else (cons x y))))
		     '()
		     (append (list multiplicand) rest))))
    (cond ((zeros? product) 0)
	  ((= (length product) 1) (car product))
	  (else (cons '* product)))))

(define (multiplier p) (cadr p))

(define (multiplicand p)
  (if (null? (cddr p))
      (cadr p)
      (apply make-product (cddr p))))

(define (addend s) (cadr s))

(define (augend s)
  (if (null? (cddr s))
      (cadr s)
      (apply make-sum (cddr s))))

(deriv '(* x y (+ x 3)) 'x)
;Value 12: (+ (* x y) (* y (+ x 3)))


;;; This seemed way too difficult until I figured out that they literally meant that I was supposed
;;; to change the augend and multiplicand procedures, not just make-sum and make-product (Though as you can tell I changed those too).



###2.58###
PROMPT:
------------------------------------------------------------
Exercise 2.58.  Suppose we want to modify the differentiation program so that it works with ordinary mathematical notation, in which + and * are infix rather than prefix operators. Since the differentiation program is defined in terms of abstract data, we can modify it to work with different representations of expressions solely by changing the predicates, selectors, and constructors that define the representation of the algebraic expressions on which the differentiator is to operate.

a. Show how to do this in order to differentiate algebraic expressions presented in infix form, such as (x + (3 * (x + (y + 2)))). To simplify the task, assume that + and * always take two arguments and that expressions are fully parenthesized.

b. The problem becomes substantially harder if we allow standard algebraic notation, such as (x + 3 * (x + y + 2)), which drops unnecessary parentheses and assumes that multiplication is done before addition. Can you design appropriate predicates, selectors, and constructors for this notation such that our derivative program still works?
------------------------------------------------------------
(define (deriv exp var)
  (cond ((number? exp) 0)
        ((variable? exp)
         (if (same-variable? exp var) 1 0))
        ((sum? exp)
         (make-sum (deriv (addend exp) var)
                   (deriv (augend exp) var)))
        ((product? exp)
         (make-sum
           (make-product (multiplier exp)
                         (deriv (multiplicand exp) var))
           (make-product (deriv (multiplier exp) var)
                         (multiplicand exp))))
	((exponentiation? exp)
	 (make-product (make-product (exponent exp)
				     (make-exponentiation (base exp) (- (exponent exp) 1)))
		       (deriv (base exp) var)))
        (else
         (error "unknown expression type -- DERIV" exp))))

(define (variable? x) (symbol? x))

(define (same-variable? v1 v2)
  (and (variable? v1) (variable? v2) (eq? v1 v2)))


(define (sum? exp)
  (and (pair? exp) (eq? (cadr exp) '+)))
(define (product? exp)
  (and (pair? exp) (eq? (cadr exp) '*)))

(define (addend exp)
  (car exp))
(define (augend exp)
  (caddr exp))

(define (multiplier exp)
  (car exp))
(define (multiplicand exp)
  (caddr exp))

(define (make-sum a b)
  (cond ((and (number? a) (number? b)) (+ a b))
	((=number? a 0) b)
	((=number? b 0) a)
	(else (list a '+ b))))

(define (make-product a b)
  (cond ((or (=number? a 0) (=number? b 0)) 0)
	((=number? a 1) b)
	((=number? b 1) a)
	((and (number? a) (number? b)) (* a b))
	(else (list a '* b))))

(deriv '(x + (3 * (x + (y + 2)))) 'x)
;Value: 4
(deriv '(x * (y * (x + 3))) 'x)
;Value 15: ((x * y) + (y * (x + 3)))



;;;;;;;PART B;;;;;;;

(define (operator exp)
  (cond ((memq '+ exp) '+)
	((memq '* exp) '*)))

(define (prefix op exp)
  (define (iter values remaining)
    (if (eq? op (car remaining))
	(reverse values)
	(iter (cons (car remaining) values)
	      (cdr remaining))))
  (iter '() exp))

(operator '(1 * 2 * 3 * 4))

(define (addend exp)
  (let ((p (prefix '+ exp)))
    (if (= (length p) 1)
	(car p)
	p)))

(define (augend exp)
  (let ((s (cdr (memq '+ exp))))
    (if (= (length s) 1)
	(car s)
	s)))

(define (sum? exp)
  (eq? (operator exp) '+))

(define (multiplier exp)
  (let ((p (prefix '* exp)))
    (if (= (length p) 1)
	(car p)
	p)))

(define (multiplicand exp)
  (let ((s (cdr (memq '* exp))))
    (if (= (length s) 1)
	(car s)
	s)))

(define (product? exp)
  (eq? (operator exp) '*))
	   

(deriv '(x + 3 * (x + y + 2)) 'x)
;Value: 4


;;; The idea for this code is borrowed from a comment on Bill the Lizard by someone named Alexey Grigorev. credit where credit is due...
;;; Once I read the first definition I realized what I had been missing. It is possible to make this work if the equation is split on
;;; addition first before multiplication. I got tripped up by the dead end of trying to make the it work by parsing each operator as
;;; the one element before and the rest being called as the rest of the list. Obviously this doesn't work when you have multiplication
;;; followed by any other elements in the list, becuase multiplication would have been applying the product rule to first and rest respectively
;;; as f(x) and g(x) and then halting.

###2.59###
PROMPT:
------------------------------------------------------------
Exercise 2.59.  Implement the union-set operation for the unordered-list representation of sets.
------------------------------------------------------------

(define (element-of-set? x set)
  (cond ((null? set) false)
        ((equal? x (car set)) true)
        (else (element-of-set? x (cdr set)))))

(define (adjoin-set x set)
  (if (element-of-set? x set)
      set
      (cons x set)))

(define (intersection-set set1 set2)
  (cond ((or (null? set1) (null? set2)) '())
        ((element-of-set? (car set1) set2)        
         (cons (car set1)
               (intersection-set (cdr set1) set2)))
        (else (intersection-set (cdr set1) set2))))

(define (union-set set1 set2)
  (cond ((and (null? set1) (null? set2)) '())
	((null? set1) set2)
	((null? set2) set1)
	((element-of-set? (car set1) set2)
	 (union-set (cdr set1) set2))
	(else (cons (car set1)
		    (union-set (cdr set1) set2)))))

(define set1 '(1 2 3 4))
(define set2 '(2 3 4 5 6 7 8))

(union-set set1 set2)
;Value 29: (1 2 3 4 5 6 7 8)

###2.60###
PROMPT:
------------------------------------------------------------
Exercise 2.60.  We specified that a set would be represented as a list with no duplicates. Now suppose we allow duplicates. For instance, the set {1,2,3} could be represented as the list (2 3 2 1 3 2 2). Design procedures element-of-set?, adjoin-set, union-set, and intersection-set that operate on this representation. How does the efficiency of each compare with the corresponding procedure for the non-duplicate representation? Are there applications for which you would use this representation in preference to the non-duplicate one?
------------------------------------------------------------

(define (element-of-set element set)
  (cond ((null? set) false)
	((equal? element (car set)) true)
	(else (element-of-set element (cdr set)))))

(define (adjoin-set element set)
  (cons element set))

(define (union-set set1 set2)
  (append set1 set2))

(define (intersection-set set1 set2)
  (cond ((or (null? set1) (null? set2)) '())
	((element-of-set (car set1) set2)
	 (adjoin-set (car set1)
		     (intersection-set (cdr set1)
				       set2)))
	(else (intersection-set (cdr set1) set2))))

(define set1 '(2 3 2 1 3 2 2))
(define set2 '(8 8 9 3 4 2))

(intersection-set set1 set2)
;Value 33: (2 3 2 3 2 2)
(union-set set1 set2)


;;; The insertions are much faster in this implementation, because they occur in constant time as opposed to linear time.
;;; Lookups, on the other hand, are going to be slower in data with a lot of repeated values, this is all dependant on the data.
;;; union-set is runs in linear time proportional to the size of set 1. this is just an append operation. Intersection set is
;;; virtually the same as before, having n^2 complexity.

;;; So it all depends on the intended use of a program. Many insertions, few lookups would favor this implementation, where
;;; Few insertions, many lookups would heavily favor the other.

###2.61###
PROMPT:
------------------------------------------------------------
Exercise 2.61.  Give an implementation of adjoin-set using the ordered representation. By analogy with element-of-set? show how to take advantage of the ordering to produce a procedure that requires on the average about half as many steps as with the unordered representation.
------------------------------------------------------------

(define (adjoin-set element set)
  (cond ((null? (cdr set)) (cons (car set) (cons element '())))
	((equal? element (car set)) set)
	((< element (cadr set)) (append (list (car set)) (list element) (cdr set)))
	(else (cons (car set) (adjoin-set element (cdr set))))))


(define (adjoin-set element set)
  (cond ((null? set) (cons element '()))
	((equal? element (car set)) set)
	((< element (car set)) (append (list element) set))
	(else (cons (car set) (adjoin-set element (cdr set))))))

(adjoin-set 5 '(1 2 3 5))
;Value 51: (1 2 3 5)

(define (union-set set1 set2)
  (cond ((and (null? set1) (null? set2)) '())
	((null? set1) set2)
	((null? set2) set1)
	(else (let ((x1 (car set1))
		    (x2 (car set2)))
		(cond ((= x1 x2) (cons x1 (union-set (cdr set1) (cdr set2))))
		      ((< x1 x2) (cons x1 (union-set (cdr set1) set2)))
		      ((< x2 x1) (cons x2 (union-set set1 (cdr set2)))))))))

(union-set '(1 2 3) '(3 4 5))
;Value 57: (1 2 3 4 5)

###2.66###
PROMPT:
------------------------------------------------------------
Exercise 2.66.  Implement the lookup procedure for the case where the set of records is structured as a binary tree, ordered by the numerical values of the keys.
------------------------------------------------------------

(define (lookup given-key set-of-records)
  (cond ((null? set-of-records) false)
	((equal? given-key (key (entry set-of-records)))
	 (entry set-of-records))
	((< (key set-of-records) (entry set-of-records))
	 (lookup given-key (left-branch set-of-records)))
	((> (key set-of-records) (entry set-of-records))
	 (lookup given-key (right-branch set-of-records)))))

###2.67###
PROMPT:
------------------------------------------------------------
Exercise 2.67.  Define an encoding tree and a sample message:

(define sample-tree
  (make-code-tree (make-leaf 'A 4)
                  (make-code-tree
                   (make-leaf 'B 2)
                   (make-code-tree (make-leaf 'D 1)
                                   (make-leaf 'C 1)))))

(define sample-message '(0 1 1 0 0 1 0 1 0 1 1 1 0))

Use the decode procedure to decode the message, and give the result.
------------------------------------------------------------

(define (make-leaf symbol weight)
  (list 'leaf symbol weight))
(define (leaf? object)
  (eq? (car object) 'leaf))
(define (symbol-leaf x) (cadr x))
(define (weight-leaf x) (caddr x))

(define (make-code-tree left right)
  (list left
        right
        (append (symbols left) (symbols right))
        (+ (weight left) (weight right))))

(define (left-branch tree) (car tree))

(define (right-branch tree) (cadr tree))
(define (symbols tree)
  (if (leaf? tree)
      (list (symbol-leaf tree))
      (caddr tree)))
(define (weight tree)
  (if (leaf? tree)
      (weight-leaf tree)
      (cadddr tree)))

(define (decode bits tree)
  (define (decode-1 bits current-branch)
    (if (null? bits)
        '()
        (let ((next-branch
               (choose-branch (car bits) current-branch)))
          (if (leaf? next-branch)
              (cons (symbol-leaf next-branch)
                    (decode-1 (cdr bits) tree))
              (decode-1 (cdr bits) next-branch)))))
  (decode-1 bits tree))
(define (choose-branch bit branch)
  (cond ((= bit 0) (left-branch branch))
        ((= bit 1) (right-branch branch))
        (else (error "bad bit -- CHOOSE-BRANCH" bit))))

(define sample-tree
  (make-code-tree (make-leaf 'A 4)
		  (make-code-tree
		   (make-leaf 'B 2)
		   (make-code-tree (make-leaf 'D 1)
				   (make-leaf 'C 1)))))

(define sample-message '(0 1 1 0 0 1 0 1 0 1 1 1 0 ))

(decode sample-message sample-tree)
;Value 12: (a d a b b c a)
sample-tree

PROMPT:
-----------------------------------------------------------------------------------------------------------------
Exercise 2.68.  The encode procedure takes as arguments a message and a tree and produces the list of bits that gives the encoded message.

(define (encode message tree)
  (if (null? message)
      '()
      (append (encode-symbol (car message) tree)
              (encode (cdr message) tree))))

Encode-symbol is a procedure, which you must write, that returns the list of bits that encodes a given symbol according to a given tree. You should design encode-symbol so that it signals an error if the symbol is not in the tree at all. Test your procedure by encoding the result you obtained in exercise 2.67 with the sample tree and seeing whether it is the same as the original sample message.
-----------------------------------------------------------------------------------------------------------------

(define (encode message tree)
  (if (null? message)
      '()
      (append (encode-symbol (car message) tree)
              (encode (cdr message) tree))))


(define (encode-symbol sym tree)
  (define (in-set? s set)
    (cond ((null? set) false)
	  ((eq? s (car set)) true)
	  (else (in-set? s (cdr set)))))
  (cond ((and (leaf? tree) (eq? sym (symbol-leaf tree))) '())
	((in-set? sym (symbols (left-branch tree))) (cons 0 (encode-symbol sym (left-branch tree))))
	((in-set? sym (symbols (right-branch tree))) (cons 1 (encode-symbol sym (right-branch tree))))
	(else (error "bad symbol -- ENCODE-SYMBOL " sym))))


(encode '(a d a b b c q) sample-tree)
;bad symbol -- ENCODE-SYMBOL  q
;To continue, call RESTART with an option number:
; (RESTART 1) => Return to read-eval-print level 1.
;Start debugger? (y or n): n

(encode '(a d a b b c a) sample-tree)
;Value 19: (0 1 1 0 0 1 0 1 0 1 1 1 0)

Exercise 2.69.  The following procedure takes as its argument a list of symbol-frequency pairs (where no symbol appears in more than one pair) and generates a Huffman encoding tree according to the Huffman algorithm.

(define (generate-huffman-tree pairs)
  (successive-merge (make-leaf-set pairs)))

Make-leaf-set is the procedure given above that transforms the list of pairs into an ordered set of leaves. Successive-merge is the procedure you must write, using make-code-tree to successively merge the smallest-weight elements of the set until there is only one element left, which is the desired Huffman tree. (This procedure is slightly tricky, but not really complicated. If you find yourself designing a complex procedure, then you are almost certainly doing something wrong. You can take significant advantage of the fact that we are using an ordered set representation.)
-----------------------------------------------------------------------------------------------------------------
(define (adjoin-set x set)
  (cond ((null? set) (list x))
        ((< (weight x) (weight (car set))) (cons x set))
        (else (cons (car set)
                    (adjoin-set x (cdr set))))))

(define (make-leaf-set pairs)
  (if (null? pairs)
      '()
      (let ((pair (car pairs)))
        (adjoin-set (make-leaf (car pair)    ; symbol
                               (cadr pair))  ; frequency
                    (make-leaf-set (cdr pairs))))))

(define (generate-huffman-tree pairs)
  (successive-merge (make-leaf-set pairs)))




(define (successive-merge pairs)
  (define (merge-iter leaf-set)
    (if (null? (cddr leaf-set))
	leaf-set
	(let ((c (car leaf-set))
	      (d (cadr leaf-set)))
	  (merge-iter (adjoin-set (make-code-tree c d) (cddr leaf-set))))))
  (merge-iter pairs))

(define leaf-set '((A 8) (Q 3) (C 1) (D 1) (E 1) (F 1) (G 1) (H 1)))

(generate-huffman-tree leaf-set)
;Value 12: (((leaf a 8) ((((leaf h 1) (leaf g 1) (h g) 2) ((leaf f 1) (leaf e 1) (f e) 2) (h g f e) 4) (((leaf d 1) (leaf c 1) (d c) 2) (leaf q 3) (d c q) 5) (h g f e d c q) 9) (a h g f e d c q) 17))

###2.70###
PROMPT:
------------------------------------------------------------
Exercise 2.70.  The following eight-symbol alphabet with associated relative frequencies was designed to efficiently encode the lyrics of 1950s rock songs. (Note that the ``symbols'' of an ``alphabet'' need not be individual letters.)

A	2	NA	16
BOOM	1	SHA	3
GET	2	YIP	9
JOB	2	WAH	1
Use generate-huffman-tree (exercise 2.69) to generate a corresponding Huffman tree, and use encode (exercise 2.68) to encode the following message:

Get a job

Sha na na na na na na na na

Get a job

Sha na na na na na na na na

Wah yip yip yip yip yip yip yip yip yip

Sha boom

How many bits are required for the encoding? What is the smallest number of bits that would be needed to encode this song if we used a fixed-length code for the eight-symbol alphabet?
------------------------------------------------------------

(define message
  '(GET A JOB
	SHA NA NA NA NA NA NA NA NA
	GET A JOB SHA NA NA NA NA NA NA NA NA
	WAH YIP YIP YIP YIP YIP YIP YIP YIP YIP
	SHA BOOM))

(define tree (generate-huffman-tree '((NA 16) (YIP 9) (SHA 3) (A 2) (GET 2) (JOB 2) (WAH 1) (BOOM 1))))
(define encoded-message (encode message tree))
;Value 17: (0 1 1 1 1 1 0 1 1 0 0 0 1 1 1 1 0 0 1 1 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 1 1 1 1 0 1 1 0 0 0 1 1 1 1 0 0 1 1 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 1 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 1 1 0 0 1 1 0 1 1)

(length encoded-message)
;Value: 84

(decode encoded-message tree)
;Value 16: (get a job sha na na na na na na na na get a job sha na na na na na na na na wah yip yip yip yip yip yip yip yip yip sha boom)


;;; 84 bits were required to encode the message with a variable length encoding. In a fixed-length encoding with 8 characters, 3 bits per character
;;; would be required (2^3). Since the message contains 36 characters, 108 bits would be required to encode the message.

###2.71###
PROMPT:
------------------------------------------------------------
Exercise 2.71.  Suppose we have a Huffman tree for an alphabet of n symbols, and that the relative frequencies of the symbols are 1, 2, 4, ..., 2n-1. Sketch the tree for n=5; for n=10. In such a tree (for general n) how many bits are required to encode the most frequent symbol? the least frequent symbol?
------------------------------------------------------------

;;; Trees drawn seperately. The most frequent symbol requires 1 bit, the least frequent requires n-1.


###2.72###
PROMPT:
-----------------------------------------------------------------------------------------------------------------
Exercise 2.72.  Consider the encoding procedure that you designed in exercise 2.68. What is the order of growth in the number of steps needed to encode a symbol? Be sure to include the number of steps needed to search the symbol list at each node encountered. To answer this question in general is difficult. Consider the special case where the relative frequencies of the n symbols are as described in exercise 2.71, and give the order of growth (as a function of n) of the number of steps needed to encode the most frequent and least frequent symbols in the alphabet.
-----------------------------------------------------------------------------------------------------------------

(define (encode-symbol sym tree)
  (define (in-set? s set)
    (cond ((null? set) false)
	  ((eq? s (car set)) true)
	  (else (in-set? s (cdr set)))))
  (cond ((and (leaf? tree) (eq? sym (symbol-leaf tree))) '())
	((in-set? sym (symbols (left-branch tree))) (cons 0 (encode-symbol sym (left-branch tree))))
	((in-set? sym (symbols (right-branch tree))) (cons 1 (encode-symbol sym (right-branch tree))))
	(else (error "bad symbol -- ENCODE-SYMBOL " sym))))



;;; For convenience I have included my algorithm above. Note that the in-set? procedure checks every element in the worst case when
;;; the element being searched for is at the end of the set list. However, the huffman tree is always constructed so that the least frequent
;;; letters are stored first in the set.

;;; In order to search for the most-frequent letter, the in-set? procedure will have to do n-1 operations to check the left-branch
;;;, but it will only take 1 operation to check the right-branch. It will find the symbol in question during the next call, and the only
;;; remaining operations
;;; are constant time consing (cons 1 '()). So we have 2 calls to encode-symbol, where the first call results in n-1 + 1 operations, and the second
;;; results in c operations. thus the algorithm runs in f(n) = theta(n)

;;; The search for the least frequent symbol will take n calls to encode-symbol to find the symbol in question. On the first n-1 calls, 3 operations
;;; are required. The first is constant time, and the second is a call to in-set, and the third is a call to cons.
;;; but this will find the symbol at the beginning of the list every
;;; time. Because of this, we have (n)(c+c+c) and so f(n) = theta(n).
