###2.1###

(define (add-rat x y)
  (make-rat (+ (* (numer x) (denom y))
	       (* (numer y) (denom x)))
	    (* (denom x) (denom y))))
(define (sub-rat x y)
  (made-rat (- (* (numer x) (denom y))
	       (* (numer y) (denom x)))
	    (* (denom x) (denom y))))
(define (mul-rat x y)
  (make-rat (* (numer x) (numer y))
	    (* (denom x) (denom y))))
(define (div-rat x y)
  (make-rat (* (numer x) (denom y))
	    (* (numer y) (denom x))))
(define (equal-rat? x y)
  (= (* (numer x) (denom y))
     (* (numer y) (denom x))))

(define (make-rat n d)
  (let ((g (gcd n d)))
    (cond ((and (negative? n) (negative? d))
	   (cons (/ (abs n) g) (/ (abs d) g)))
	  ((negative? d)
	   (cons (/ (negate n) g) (/ (negate d) g)))
	  (else
	   (cons (/ n g) (/ d g))))))
(define (numer x) (car x))
(define (denom x) (cdr x))
(define (negative? x)
  (< x 0))
(define (negate x)
  (- x))
(define (print-rat x)
  (newline)
  (display (numer x))
  (display "/")
  (display (denom x)))

(print-rat (make-rat -20 -4))
(print-rat (mul-rat (make-rat -20 -8) (make-rat 3 -7)))

###2.2###

(define (make-segment start end)
  (cons start end))
(define (start-segment s)
  (car s))
(define (end-segment s)
  (cdr s))
(define (make-point x y)
  (cons x y))
(define (x-point p)
  (car p))
(define (y-point p)
  (cdr p))
(define (print-point p)
  (newline)
  (display "(")
  (display (x-point p))
  (display ",")
  (display (y-point p))
  (display ")"))
(define (average s f)
  (/ (+ (f (start-segment s))
	(f (end-segment s)))
     2))
(define (midpoint s)
  (make-point (average s x-point)
	      (average s y-point)))

(let ((point1 (make-point 2 4))(point2 (make-point 4 0)))
  (let ((seg (make-segment point1 point2)))
    (print-point (midpoint seg))))


###2.3###

The following code is common to both implementations of rectangle:

(define (make-segment start end)
  (cons start end))
(define (start-segment s)
  (car s))
(define (end-segment s)
  (cdr s))
(define (make-point x y)
  (cons x y))
(define (x-point p)
  (car p))
(define (y-point p)
  (cdr p))
(define (print-point p)
  (newline)
  (display "(")
  (display (x-point p))
  (display ",")
  (display (y-point p))
  (display ")"))
(define (average s f)
  (/ (+ (f (start-segment s))
	(f (end-segment s)))
     2))
(define (midpoint s)
  (make-point (average s x-point)
	      (average s y-point)))
(define (length-segment s)
  (hypotenuse s))
(define (hypotenuse s)
  (sqrt (+ (square (grid-distance s x-point))
	   (square (grid-distance s y-point)))))
(define (grid-distance seg coord)
  (abs (- (coord (end-segment seg))
	  (coord (start-segment seg)))))

@@@PART A@@@

(define (make-rectangle p1 p2 p3 p4)
  (cons (cons p1 p2) (cons p3 p4)))
(define (rect-point1 r)
  (car (car r)))
(define (rect-point2 r)
  (cdr (car r)))
(define (rect-point3 r)
  (car (cdr r)))
(define (rect-point4 r)
  (cdr (cdr r)))
(define (rect-side1 r)
  (make-segment (rect-point1 r) (rect-point2 r)))
(define (rect-side2 r)
  (make-segment (rect-point2 r) (rect-point3 r)))
(define (rect-side3 r)
  (make-segment (rect-point3 r) (rect-point4 r)))
(define (rect-side4 r)
  (make-segment (rect-point4 r) (rect-point1 r)))
(define (rect-length r)
  (length-segment (rect-side1 r)))
(define (rect-width r)
  (length-segment (rect-side2 r)))
(define (rect-perimeter r)
  (* 2 (+ (rect-length r)
	  (rect-width r))))
(define (rect-area r)
  (* (rect-length r)
     (rect-width r)))

(let ((p1 (make-point 0 0))
      (p2 (make-point 4 0))
      (p3 (make-point 4 4))
      (p4 (make-point 0 4)))
  (let ((rect1 (make-rectangle p1 p2 p3 p4)))
    (newline)
    (display "Perimeter: ")
    (display (rect-perimeter rect1))
    (newline)
    (display "Area: ")
    (display (rect-area rect1))))
Perimeter: 16
Area: 16

(let ((p1 (make-point 0 0))
      (p2 (make-point 8 0))
      (p3 (make-point 8 4))
      (p4 (make-point 0 4)))
  (let ((rect1 (make-rectangle p1 p2 p3 p4)))
    (newline)
    (display "Perimeter: ")
    (display (rect-perimeter rect1))
    (newline)
    (display "Area: ")
    (display (rect-area rect1))))
Perimeter: 24
Area: 32

Here's my first implementation of rectangle. There are many ways that rectangle could be designed. This implementation has the
advantage that it would be easily extended (because it is easy to access all of the points and line segments of the rectangle).
The disadvantage is that for the purposes of just getting perimeter and area, it uses a lot of storage, and is relatively costly.

@@@PART B@@@

(define (make-length p1 p2)
  (make-segment p1 (make-point (x-point p2) (y-point p1))))
(define (make-width p1 p2)
  (make-segment p1 (make-point (x-point p1) (y-point p2))))
(define (make-rectangle p1 p2)
  (cons (make-length p1 p2)
	(make-width p1 p2)))
(define (rect-length r)
  (length-segment (car r)))
(define (rect-width r)
  (length-segment (cdr r)))
(define (rect-perimeter r)
  (* 2 (+ (rect-length r)
	  (rect-width r))))
(define (rect-area r)
  (* (rect-length r)
     (rect-width r)))
(let ((p1 (make-point 0 0))
      (p2 (make-point 4 4)))
  (let ((rect1 (make-rectangle p1 p2)))
    (newline)
    (display "Perimeter: ")
    (display (rect-perimeter rect1))
    (newline)
    (display "Area: ")
    (display (rect-area rect1))))
Perimeter: 16
Area: 16

(let ((p1 (make-point 0 0))
      (p2 (make-point 8 4)))
  (let ((rect1 (make-rectangle p1 p2)))
    (newline)
    (display "Perimeter: ")
    (display (rect-perimeter rect1))
    (newline)
    (display "Area: ")
    (display (rect-area rect1))))
Perimeter: 24
Area: 32

Here's my second, much more streamlined implementation. Rectangle only accepts two points as parameters, and figures out the missing points.
It knows this because both length sides will be the same and both width sides will also be the same. Furthermore, this version of
rectangle doesn't store all of the points explicitly. It only stores 2 line segments, 1 for width and 1 for length. The selectors
don't even return a segment, just the length of each respective line. Notice that the implementation of perimeter and area are identical to
PART A, and both functions behave identically, thus we have achieved the goal of abstraction barriers between perimeter, area, and the underlying
data structures.

###2.4###

(define (cons x y)
  (lambda (m) (m x y)))

(define (car m)
  (z (lambda (p q) p)))

***Substitution model***

(car (cons x y))
(car (lambda (m) (m x y)))
(car #[compound-procedure 12])
(#[compound-procedure 12] (lambda (p q) p))
(#[compound-procedure 12] #[compound-procedure 13])
---for the sake of clarity ill write out the lambda procedures)
((lambda (m) (m x y)) (lambda (p q) p))
((lambda (p q) p) x y)
((lambda (x y) x) x y) ;;;<---which is like saying
x

So, the corresponding definition of cdr is as follows:

(define (cdr z)
  (z (lambda (p q) q)))


###2.5###

(define (mod b n)
  (mod-iter b n 0 0))
(define (mod-iter b n r c)
  (if (not (= 0 r))
      (- c 1)
      (mod-iter b (/ n b) (remainder n b) (+ c 1))))
(mod 2 (* (expt 2 4) (expt 3 3)))
(define (cons a b)
  (let ((p (* (expt 2 a) (expt 3 b))))
    (define deliver (lambda (b) (mod b p)))
    deliver))
(define (car m)
  ((lambda (m) (m 2)) m))
(define (cdr m)
  ((lambda (m) (m 3)) m))

(car (cons 4 5))
(cdr (cons 4 5))

It is amazing how well this course fits with 6.042J (which I'm taking in parallel, and for that class I just read a chapter on number theory).

###2.6###

Heres the prompt:

--------------------------------------------------------------------------------
Exercise 2.6.  In case representing pairs as procedures wasn't mind-boggling enough, consider that, in a language that can manipulate procedures, we can get by without numbers (at least insofar as nonnegative integers are concerned) by implementing 0 and the operation of adding 1 as

(define zero (lambda (f) (lambda (x) x)))

(define (add-1 n)
  (lambda (f) (lambda (x) (f ((n f) x)))))

This representation is known as Church numerals, after its inventor, Alonzo Church, the logician who invented the  calculus.

Define one and two directly (not in terms of zero and add-1). (Hint: Use substitution to evaluate (add-1 zero)). Give a direct definition of the addition procedure + (not in terms of repeated application of add-1).
--------------------------------------------------------------------------------

So let's just follow the hint of using the substitution model and see if we can figure out what in the world is going on here.

(add-1 zero)

(add-1 (lambda (f) (lambda (x) x)))
(lambda (f) (lambda (x) (f (((lambda (f) (lambda (x) x)) f) x))))
(lambda (f) (lambda (x) (f ((lambda (x) x)) x))))
(lambda (f) (lambda (x) (f x)))) <<<-----direct definition of one

(add-1 (add-1 zero))
(add-1 (add-1 (lambda (f) (lambda (x) x))))
(add-1 (lambda (f) (lambda (x) (f (((lambda (f) (lambda (x) x)) f x)))))
(add-1 (lambda (f) (lambda (x) (f ((lambda (x) x)) x))))
(add-1 (lambda (f) (lambda (x) (f x))))
(lambda (f) (lambda (x) (f (((lambda (f) (lambda (x) (f x)))) f) x)))
(lambda (f) (lambda (x) (f ((lambda (x) (f x)))) x)))
(lambda (f) (lambda (x) (f (f x)))) <<<-----direct definition of two


(define (+ n1 n2)
  (lambda (f) (lambda (x) ((n1 f) ((n2 f) x))))) <<<-----direct definition of add

(+ (lambda (f) (lambda (x) (f (f x)))) (lambda (f) (lambda (x) (f x)))) ;;; Here I'm adding one and two
(lambda (f) (lambda (x) (((lambda (f) (lambda (x) (f (f x)))) f) (((lambda (f) (lambda (x) (f x))) f) x))))
(lambda (f) (lambda (x) (((lambda (f) (lambda (x) (f (f x)))) f) ((lambda (x) (f x)) x))))
(lambda (f) (lambda (x) (((lambda (f) (lambda (x) (f (f x)))) f) (f x))))
(lambda (f) (lambda (x) ((lambda (x) (f (f x))) (f x))))
(lambda (f) (lambda (x) (f (f (f x)))))

While this has been an eye opening experience, the usefulness here doesn't exactly blow me away. One of the huge aspects of good code is that
it should be readable. I spent 2 or so hours trying to think through all of the twists and contortions that the procedures are doing here.
While it is elegant, the practical use is not apparent to me. When I was trying to read the code, I found that telling myself "Well, this is a procedure, that takes f
and returns a procedure that takes x, which applies f with x substituted in to a composition of n and f" to be entirely confusing and inadequate for
understanding what is going on. While eventually I did grasp the idea here, it wasn't without struggle. perhaps the lesson I learned is to never write code
like this if I plan on having anyone else read it.


###2.7###

PROMPT:
-----------------------------------------------------------------------------------------------------------------
Exercise 2.7.  Alyssa's program is incomplete because she has not specified the implementation of the interval abstraction. Here is a definition of the interval constructor:

(define (make-interval a b) (cons a b))

Define selectors upper-bound and lower-bound to complete the implementation.
-----------------------------------------------------------------------------------------------------------------

(define (add-interval x y)
  (make-interval (+ (lower-bound x) (lower-bound y))
                 (+ (upper-bound x) (upper-bound y))))


(define (mul-interval x y)
  (let ((p1 (* (lower-bound x) (lower-bound y)))
        (p2 (* (lower-bound x) (upper-bound y)))
        (p3 (* (upper-bound x) (lower-bound y)))
        (p4 (* (upper-bound x) (upper-bound y))))
    (make-interval (min p1 p2 p3 p4)
                   (max p1 p2 p3 p4))))

(define (div-interval x y)
  (mul-interval x 
                (make-interval (/ 1.0 (upper-bound y))
                               (/ 1.0 (lower-bound y)))))

(define (make-interval a b) (cons a b))
(define (lower-bound i)
  (car i))
(define (upper-bound i)
  (cdr i))

(let ((i1 (make-interval 6.12 7.48))
      (i2 (make-interval 4.47 4.94)))
  (add-interval i1 i2))

###2.8###

PROMPT:
------------------------------------------------------------
Exercise 2.8.  Using reasoning analogous to Alyssa's, describe how the difference of two intervals may be computed. Define a corresponding subtraction procedure, called sub-interval.
------------------------------------------------------------

(define (sub-interval x y)
  (make-interval (- (lower-bound x) (lower-bound y))
		 (- (upper-bound x) (upper-bound y))))

(let ((i1 (make-interval 6.12 7.48))
      (i2 (make-interval 4.47 4.94)))
  (sub-interval i1 i2))


This procedure simply takes two intervals as arguments and returns a new interval, which has a lower bound of the difference between lower bounds of x and y, and its upper bound is defined as the difference between the upper bounds of x and y.

###2.9###

PROMPT:
------------------------------------------------------------
Exercise 2.9.  The width of an interval is half of the difference between its upper and lower bounds. The width is a measure of the uncertainty of the number specified by the interval. For some arithmetic operations the width of the result of combining two intervals is a function only of the widths of the argument intervals, whereas for others the width of the combination is not a function of the widths of the argument intervals. Show that the width of the sum (or difference) of two intervals is a function only of the widths of the intervals being added (or subtracted). Give examples to show that this is not true for multiplication or division.
------------------------------------------------------------

consider an interval i1 which has upper bound h1 and lower bound l1, and also consider an interval i2 which has upper bound h2 and lower bound l2:

Using the definition of width, we can combine the intervals through addition, and then find their width.

width = (high - low)/2

total_added_width = ((h1+h2)-(l1+l2))/2

Or, we find that we can find the width of i1 and i2, add their widths, and we have the same result:

width1 = (h1-l1)/2
width2 = (h2-l2)/2
combined_added_width = (h1-l1)/2 + (h2-l2)/2 = (h1-l1+h2-l2)/2 = ((h1+h2)-(l1+l2))/2

Now, we can also confirm the same phenomenon with subtraction.

total_subtracted_width = ((h1-h2)-(l1-l2))/2

Now we find each width seperately and combine:

width1 = (h1-l1)/2
width2 = (h2-l2)/2
combinded_subracted_width = (h1-l1)/2 - (h2-l2)/2 = ((h1-l1)-(h2-l2))/2 = (h1-l1-h2+l2)/2 = ((h1-h2)-(l1-l2))/2

so, again, we see that the results are the same.


Ok, so lets consider multiplication of widths by example.

consider the interval (-1,1) and (-2,3)

When we multiply these intervals, we get (-3, 3), which would give a width of 3. This is not the same as multiplying the widths of the original intervals,
which is 1*2.5=2.5

Furthermore, the same intervals demonstrate that we cannot derive the widths through division of the intervals.

The process that divides intervals multiplies x times the reciprocal of y.

So first we take the reciprocal fo y (with upper and lower bound switched), which is (1/3,-1/2).

Then we simply have the multiplication process of (-1,1)*(1/3,-1/2), which results in (-1/2,1/2), and a width of 1/2.
We cannot derive this same width by dividing the widths of x and y, (1/2.5), which results in 2/5.


###2.10###

PROMPT:
------------------------------------------------------------
Exercise 2.10.  Ben Bitdiddle, an expert systems programmer, looks over Alyssa's shoulder and comments that it is not clear what it means to divide by an interval that spans zero. Modify Alyssa's code to check for this condition and to signal an error if it occurs.
------------------------------------------------------------

The problem of dividing by an interval that spans 0 is that an interval describes merely where a number could occur. Thus, the number could in fact be 0.
Our division procedure is allowing a potential division by zero error to procede uninhibited. This should return an undefined, so let's see what that would
look like.

(define (div-interval x y)
  (if (and (>= (upper-bound x) 0) (<= (lower-bound y) 0))
      (error "Division by an interval that spans 0 is undefined:" y)
      (mul-interval x 
		    (make-interval (/ 1.0 (upper-bound y))
				   (/ 1.0 (lower-bound y))))))


(define (add-interval x y)
  (make-interval (+ (lower-bound x) (lower-bound y))
                 (+ (upper-bound x) (upper-bound y))))


(define (mul-interval x y)
  (let ((p1 (* (lower-bound x) (lower-bound y)))
        (p2 (* (lower-bound x) (upper-bound y)))
        (p3 (* (upper-bound x) (lower-bound y)))
        (p4 (* (upper-bound x) (upper-bound y))))
    (make-interval (min p1 p2 p3 p4)
                   (max p1 p2 p3 p4))))

(define (make-interval a b) (cons a b))
(define (lower-bound i)
  (car i))
(define (upper-bound i)
  (cdr i))

(let ((i1 (make-interval 6.12 7.48))
      (i2 (make-interval -4.47 4.94)))
  (div-interval i1 i2))


###2.11###

PROMPT:
------------------------------------------------------------
Exercise 2.11.  In passing, Ben also cryptically comments: "By testing the signs of the endpoints of the intervals, it is possible to break mul-interval into nine cases, only one of which requires more than two multiplications." Rewrite this procedure using Ben's suggestion.
------------------------------------------------------------

There are 16 possible permutations of the signs of the numbers:

++ ++
++ +-
++ --
+- --
+- -+
+- ++
+- +-
++ -+
-+ ++
-+ +-
-+ --
-- --
-- -+
-- ++
-- +-
-+ -+

Of these, only 9 are possible, because 7 have an interval where the upper-bound is less than the lower-bound. Let's explore the multiplications that we need to make.

++ ++ (1,3) (2,4)X
++ -- (2,3) (1,4)X
++ -+ (2,3) (2,4)X
-+ ++ (1,4) (2,4)X
-+ -- (2,3) (1,3)X
-- -- (2,4) (1,3)X
-- -+ (1,4) (1,3)X
-- ++ (1,4) (2,3)X
-+ -+ (1,4)/(2,3) (1,3)/(2,4)X

(the X indicates that I tested each case with the new implementation)

Now we have an idea of how to implement mul-interval:

(define (mul-interval x y)
  (let ((a (lower-bound x))
	(b (upper-bound x))
	(c (lower-bound y))
	(d (upper-bound y)))
    (define (test-mul w x y z comp)
      (if (comp (* w x) (* y z))
	  (* w x)
	  (* y z)))
    (define (interval-by-index w x y z)
      (make-interval (* w x)
		     (* y z)))
    (if (> a 0)
	(if (> c 0)
	    (interval-by-index a c b d) ;;; ++++
	    (if (> d 0)
		(interval-by-index b c b d) ;;; ++-+
		(interval-by-index b c a d))) ;;; ++--
	(if (> b 0)
	    (if (> c 0)
		(interval-by-index a d b d) ;;; -+++
		(if (> d 0)
		    (make-interval (test-mul a d b c <)
				   (test-mul a c b d >)) ;;; -+-+
		    (interval-by-index b c a c))) ;;; -+--
	    (if (> c 0)
		(interval-by-index a d b c) ;;; --++
		(if (> d 0)
		    (interval-by-index a d a c) ;;; ---+
		    (interval-by-index b d a c))))))) ;;; ----

First, I saved each low and high value for both intervals as a b c d. This will reduce the number of times we need to access the selectors,
 and makes the code more readable. Additionally, The nested if structure may appear to be unneccessarily complicated. However, using a cond statement would
require 8 comparisons in the worst case. This implementation only requires 4 in the worst case, in the best case only 2.

###2.12###

PROMPT:
------------------------------------------------------------
Exercise 2.12.  Define a constructor make-center-percent that takes a center and a percentage tolerance and produces the desired interval. You must also define a selector percent that produces the percentage tolerance for a given interval. The center selector is the same as the one shown above.
------------------------------------------------------------

(define (make-center-width c w)
  (make-interval (- c w) (+ c w)))
(define (center i)
  (/ (+ (lower-bound i) (upper-bound i)) 2))
(define (width i)
  (/ (- (upper-bound i) (lower-bound i)) 2))


(define (make-center-percent center tolerance)
  (make-interval (- center (* center (/ tolerance 100)))
		 (+ center (* center (/ tolerance 100)))))
(define (percent i)
  (* (/ (width i) (center i)) 100))

(make-center-percent 10 10)
;Value 16: (9 . 11)

(percent (make-center-percent 10 10))
;Value: 10

###2.13###

PROMPT:
------------------------------------------------------------
Exercise 2.13.  Show that under the assumption of small percentage tolerances there is a simple formula for the approximate percentage tolerance of the product of two intervals in terms of the tolerances of the factors. You may simplify the problem by assuming that all numbers are positive.
------------------------------------------------------------

The resistance of the new interval can be described by:

Wp = (1/((1/W1)+(1/W2)))

and the new center point can be calculated by:

Cp = ((C1*C2)/2)*Wp

since center = width/resistance, we have:

Wp/Rp = ((C1*C2)/2)*Wp

Rp = 1/((C1*c2)/2)

and therefore:

Rp = 2/(C1*C2)

We can also describe this by

Rp = 2/((W1*W2)/(R1/R2)) 

Based on the information we start with, we can now find the resistance of two circuits in parallel in two ways.
I found this answer in a rather circuitous manner, so the mathematical argument might not be exactly linear, but it works.

Here's an implementation using the centers of two intervals

(define (par-res i j)
  (* 100 (/ 2 (* (center i) (center j)))))

(let ((i (make-center-percent 6.8 10))
      (j (make-center-percent 4.7 5)))
  (par-res i j))
;Value: 6.25782227784731
