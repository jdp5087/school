###2.1###

(define (add-rat x y)
  (make-rat (+ (* (numer x) (denom y))
	       (* (numer y) (denom x)))
	    (* (denom x) (denom y))))
(define (sub-rat x y)
  (made-rat (- (* (numer x) (denom y))
	       (* (numer y) (denom x)))
	    (* (denom x) (denom y))))
(define (mul-rat x y)
  (make-rat (* (numer x) (numer y))
	    (* (denom x) (denom y))))
(define (div-rat x y)
  (make-rat (* (numer x) (denom y))
	    (* (numer y) (denom x))))
(define (equal-rat? x y)
  (= (* (numer x) (denom y))
     (* (numer y) (denom x))))

(define (make-rat n d)
  (let ((g (gcd n d)))
    (cond ((and (negative? n) (negative? d))
	   (cons (/ (abs n) g) (/ (abs d) g)))
	  ((negative? d)
	   (cons (/ (negate n) g) (/ (negate d) g)))
	  (else
	   (cons (/ n g) (/ d g))))))
(define (numer x) (car x))
(define (denom x) (cdr x))
(define (negative? x)
  (< x 0))
(define (negate x)
  (- x))
(define (print-rat x)
  (newline)
  (display (numer x))
  (display "/")
  (display (denom x)))

(print-rat (make-rat -20 -4))
(print-rat (mul-rat (make-rat -20 -8) (make-rat 3 -7)))

###2.2###

(define (make-segment start end)
  (cons start end))
(define (start-segment s)
  (car s))
(define (end-segment s)
  (cdr s))
(define (make-point x y)
  (cons x y))
(define (x-point p)
  (car p))
(define (y-point p)
  (cdr p))
(define (print-point p)
  (newline)
  (display "(")
  (display (x-point p))
  (display ",")
  (display (y-point p))
  (display ")"))
(define (average s f)
  (/ (+ (f (start-segment s))
	(f (end-segment s)))
     2))
(define (midpoint s)
  (make-point (average s x-point)
	      (average s y-point)))

(let ((point1 (make-point 2 4))(point2 (make-point 4 0)))
  (let ((seg (make-segment point1 point2)))
    (print-point (midpoint seg))))


###2.3###

The following code is common to both implementations of rectangle:

(define (make-segment start end)
  (cons start end))
(define (start-segment s)
  (car s))
(define (end-segment s)
  (cdr s))
(define (make-point x y)
  (cons x y))
(define (x-point p)
  (car p))
(define (y-point p)
  (cdr p))
(define (print-point p)
  (newline)
  (display "(")
  (display (x-point p))
  (display ",")
  (display (y-point p))
  (display ")"))
(define (average s f)
  (/ (+ (f (start-segment s))
	(f (end-segment s)))
     2))
(define (midpoint s)
  (make-point (average s x-point)
	      (average s y-point)))
(define (length-segment s)
  (hypotenuse s))
(define (hypotenuse s)
  (sqrt (+ (square (grid-distance s x-point))
	   (square (grid-distance s y-point)))))
(define (grid-distance seg coord)
  (abs (- (coord (end-segment seg))
	  (coord (start-segment seg)))))

@@@PART A@@@

(define (make-rectangle p1 p2 p3 p4)
  (cons (cons p1 p2) (cons p3 p4)))
(define (rect-point1 r)
  (car (car r)))
(define (rect-point2 r)
  (cdr (car r)))
(define (rect-point3 r)
  (car (cdr r)))
(define (rect-point4 r)
  (cdr (cdr r)))
(define (rect-side1 r)
  (make-segment (rect-point1 r) (rect-point2 r)))
(define (rect-side2 r)
  (make-segment (rect-point2 r) (rect-point3 r)))
(define (rect-side3 r)
  (make-segment (rect-point3 r) (rect-point4 r)))
(define (rect-side4 r)
  (make-segment (rect-point4 r) (rect-point1 r)))
(define (rect-length r)
  (length-segment (rect-side1 r)))
(define (rect-width r)
  (length-segment (rect-side2 r)))
(define (rect-perimeter r)
  (* 2 (+ (rect-length r)
	  (rect-width r))))
(define (rect-area r)
  (* (rect-length r)
     (rect-width r)))

(let ((p1 (make-point 0 0))
      (p2 (make-point 4 0))
      (p3 (make-point 4 4))
      (p4 (make-point 0 4)))
  (let ((rect1 (make-rectangle p1 p2 p3 p4)))
    (newline)
    (display "Perimeter: ")
    (display (rect-perimeter rect1))
    (newline)
    (display "Area: ")
    (display (rect-area rect1))))
Perimeter: 16
Area: 16

(let ((p1 (make-point 0 0))
      (p2 (make-point 8 0))
      (p3 (make-point 8 4))
      (p4 (make-point 0 4)))
  (let ((rect1 (make-rectangle p1 p2 p3 p4)))
    (newline)
    (display "Perimeter: ")
    (display (rect-perimeter rect1))
    (newline)
    (display "Area: ")
    (display (rect-area rect1))))
Perimeter: 24
Area: 32

Here's my first implementation of rectangle. There are many ways that rectangle could be designed. This implementation has the
advantage that it would be easily extended (because it is easy to access all of the points and line segments of the rectangle).
The disadvantage is that for the purposes of just getting perimeter and area, it uses a lot of storage, and is relatively costly.

@@@PART B@@@

(define (make-length p1 p2)
  (make-segment p1 (make-point (x-point p2) (y-point p1))))
(define (make-width p1 p2)
  (make-segment p1 (make-point (x-point p1) (y-point p2))))
(define (make-rectangle p1 p2)
  (cons (make-length p1 p2)
	(make-width p1 p2)))
(define (rect-length r)
  (length-segment (car r)))
(define (rect-width r)
  (length-segment (cdr r)))
(define (rect-perimeter r)
  (* 2 (+ (rect-length r)
	  (rect-width r))))
(define (rect-area r)
  (* (rect-length r)
     (rect-width r)))
(let ((p1 (make-point 0 0))
      (p2 (make-point 4 4)))
  (let ((rect1 (make-rectangle p1 p2)))
    (newline)
    (display "Perimeter: ")
    (display (rect-perimeter rect1))
    (newline)
    (display "Area: ")
    (display (rect-area rect1))))
Perimeter: 16
Area: 16

(let ((p1 (make-point 0 0))
      (p2 (make-point 8 4)))
  (let ((rect1 (make-rectangle p1 p2)))
    (newline)
    (display "Perimeter: ")
    (display (rect-perimeter rect1))
    (newline)
    (display "Area: ")
    (display (rect-area rect1))))
Perimeter: 24
Area: 32

Here's my second, much more streamlined implementation. Rectangle only accepts two points as parameters, and figures out the missing points.
It knows this because both length sides will be the same and both width sides will also be the same. Furthermore, this version of
rectangle doesn't store all of the points explicitly. It only stores 2 line segments, 1 for width and 1 for length. The selectors
don't even return a segment, just the length of each respective line. Notice that the implementation of perimeter and area are identical to
PART A, and both functions behave identically, thus we have achieved the goal of abstraction barriers between perimeter, area, and the underlying
data structures.

###2.4###

(define (cons x y)
  (lambda (m) (m x y)))

(define (car m)
  (z (lambda (p q) p)))

***Substitution model***

(car (cons x y))
(car (lambda (m) (m x y)))
(car #[compound-procedure 12])
(#[compound-procedure 12] (lambda (p q) p))
(#[compound-procedure 12] #[compound-procedure 13])
---for the sake of clarity ill write out the lambda procedures)
((lambda (m) (m x y)) (lambda (p q) p))
((lambda (p q) p) x y)
((lambda (x y) x) x y) ;;;<---which is like saying
x

So, the corresponding definition of cdr is as follows:

(define (cdr z)
  (z (lambda (p q) q)))


###2.5###

(define (mod b n)
  (mod-iter b n 0 0))
(define (mod-iter b n r c)
  (if (not (= 0 r))
      (- c 1)
      (mod-iter b (/ n b) (remainder n b) (+ c 1))))
(mod 2 (* (expt 2 4) (expt 3 3)))
(define (cons a b)
  (let ((p (* (expt 2 a) (expt 3 b))))
    (define deliver (lambda (b) (mod b p)))
    deliver))
(define (car m)
  ((lambda (m) (m 2)) m))
(define (cdr m)
  ((lambda (m) (m 3)) m))

(car (cons 4 5))
(cdr (cons 4 5))

It is amazing how well this course fits with 6.042J (which I'm taking in parallel, and for that class I just read a chapter on number theory).

###2.6###

Heres the prompt:

--------------------------------------------------------------------------------
Exercise 2.6.  In case representing pairs as procedures wasn't mind-boggling enough, consider that, in a language that can manipulate procedures, we can get by without numbers (at least insofar as nonnegative integers are concerned) by implementing 0 and the operation of adding 1 as

(define zero (lambda (f) (lambda (x) x)))

(define (add-1 n)
  (lambda (f) (lambda (x) (f ((n f) x)))))

This representation is known as Church numerals, after its inventor, Alonzo Church, the logician who invented the  calculus.

Define one and two directly (not in terms of zero and add-1). (Hint: Use substitution to evaluate (add-1 zero)). Give a direct definition of the addition procedure + (not in terms of repeated application of add-1).
--------------------------------------------------------------------------------

So let's just follow the hint of using the substitution model and see if we can figure out what in the world is going on here.

(add-1 zero)

(add-1 (lambda (f) (lambda (x) x)))
(lambda (f) (lambda (x) (f (((lambda (f) (lambda (x) x)) f) x))))
(lambda (f) (lambda (x) (f ((lambda (x) x)) x))))
(lambda (f) (lambda (x) (f x)))) <<<-----direct definition of one

(add-1 (add-1 zero))
(add-1 (add-1 (lambda (f) (lambda (x) x))))
(add-1 (lambda (f) (lambda (x) (f (((lambda (f) (lambda (x) x)) f x)))))
(add-1 (lambda (f) (lambda (x) (f ((lambda (x) x)) x))))
(add-1 (lambda (f) (lambda (x) (f x))))
(lambda (f) (lambda (x) (f (((lambda (f) (lambda (x) (f x)))) f) x)))
(lambda (f) (lambda (x) (f ((lambda (x) (f x)))) x)))
(lambda (f) (lambda (x) (f (f x)))) <<<-----direct definition of two


(define (+ n1 n2)
  (lambda (f) (lambda (x) ((n1 f) ((n2 f) x))))) <<<-----direct definition of add

(+ (lambda (f) (lambda (x) (f (f x)))) (lambda (f) (lambda (x) (f x)))) ;;; Here I'm adding one and two
(lambda (f) (lambda (x) (((lambda (f) (lambda (x) (f (f x)))) f) (((lambda (f) (lambda (x) (f x))) f) x))))
(lambda (f) (lambda (x) (((lambda (f) (lambda (x) (f (f x)))) f) ((lambda (x) (f x)) x))))
(lambda (f) (lambda (x) (((lambda (f) (lambda (x) (f (f x)))) f) (f x))))
(lambda (f) (lambda (x) ((lambda (x) (f (f x))) (f x))))
(lambda (f) (lambda (x) (f (f (f x)))))

While this has been an eye opening experience, the usefulness here doesn't exactly blow me away. One of the huge aspects of good code is that
it should be readable. I spent 2 or so hours trying to think through all of the twists and contortions that the procedures are doing here.
While it is elegant, the practical use is not apparent to me. When I was trying to read the code, I found that telling myself "Well, this is a procedure, that takes f
and returns a procedure that takes x, which applies f with x substituted in to a composition of n and f" to be entirely confusing and inadequate for
understanding what is going on. While eventually I did grasp the idea here, it wasn't without struggle. perhaps the lesson I learned is to never write code
like this if I plan on having anyone else read it.


###2.7###

PROMPT:
-----------------------------------------------------------------------------------------------------------------
Exercise 2.7.  Alyssa's program is incomplete because she has not specified the implementation of the interval abstraction. Here is a definition of the interval constructor:

(define (make-interval a b) (cons a b))

Define selectors upper-bound and lower-bound to complete the implementation.
-----------------------------------------------------------------------------------------------------------------

(define (add-interval x y)
  (make-interval (+ (lower-bound x) (lower-bound y))
                 (+ (upper-bound x) (upper-bound y))))


(define (mul-interval x y)
  (let ((p1 (* (lower-bound x) (lower-bound y)))
        (p2 (* (lower-bound x) (upper-bound y)))
        (p3 (* (upper-bound x) (lower-bound y)))
        (p4 (* (upper-bound x) (upper-bound y))))
    (make-interval (min p1 p2 p3 p4)
                   (max p1 p2 p3 p4))))

(define (div-interval x y)
  (mul-interval x 
                (make-interval (/ 1.0 (upper-bound y))
                               (/ 1.0 (lower-bound y)))))

(define (make-interval a b) (cons a b))
(define (lower-bound i)
  (car i))
(define (upper-bound i)
  (cdr i))

(let ((i1 (make-interval 6.12 7.48))
      (i2 (make-interval 4.47 4.94)))
  (add-interval i1 i2))

###2.8###

PROMPT:
------------------------------------------------------------
Exercise 2.8.  Using reasoning analogous to Alyssa's, describe how the difference of two intervals may be computed. Define a corresponding subtraction procedure, called sub-interval.
------------------------------------------------------------

(define (sub-interval x y)
  (make-interval (- (lower-bound x) (lower-bound y))
		 (- (upper-bound x) (upper-bound y))))

(let ((i1 (make-interval 6.12 7.48))
      (i2 (make-interval 4.47 4.94)))
  (sub-interval i1 i2))


This procedure simply takes two intervals as arguments and returns a new interval, which has a lower bound of the difference between lower bounds of x and y, and its upper bound is defined as the difference between the upper bounds of x and y.

###2.9###

PROMPT:
------------------------------------------------------------
Exercise 2.9.  The width of an interval is half of the difference between its upper and lower bounds. The width is a measure of the uncertainty of the number specified by the interval. For some arithmetic operations the width of the result of combining two intervals is a function only of the widths of the argument intervals, whereas for others the width of the combination is not a function of the widths of the argument intervals. Show that the width of the sum (or difference) of two intervals is a function only of the widths of the intervals being added (or subtracted). Give examples to show that this is not true for multiplication or division.
------------------------------------------------------------

consider an interval i1 which has upper bound h1 and lower bound l1, and also consider an interval i2 which has upper bound h2 and lower bound l2:

Using the definition of width, we can combine the intervals through addition, and then find their width.

width = (high - low)/2

total_added_width = ((h1+h2)-(l1+l2))/2

Or, we find that we can find the width of i1 and i2, add their widths, and we have the same result:

width1 = (h1-l1)/2
width2 = (h2-l2)/2
combined_added_width = (h1-l1)/2 + (h2-l2)/2 = (h1-l1+h2-l2)/2 = ((h1+h2)-(l1+l2))/2

Now, we can also confirm the same phenomenon with subtraction.

total_subtracted_width = ((h1-h2)-(l1-l2))/2

Now we find each width seperately and combine:

width1 = (h1-l1)/2
width2 = (h2-l2)/2
combinded_subracted_width = (h1-l1)/2 - (h2-l2)/2 = ((h1-l1)-(h2-l2))/2 = (h1-l1-h2+l2)/2 = ((h1-h2)-(l1-l2))/2

so, again, we see that the results are the same.


Ok, so lets consider multiplication of widths by example.

consider the interval (-1,1) and (-2,3)

When we multiply these intervals, we get (-3, 3), which would give a width of 3. This is not the same as multiplying the widths of the original intervals,
which is 1*2.5=2.5

Furthermore, the same intervals demonstrate that we cannot derive the widths through division of the intervals.

The process that divides intervals multiplies x times the reciprocal of y.

So first we take the reciprocal fo y (with upper and lower bound switched), which is (1/3,-1/2).

Then we simply have the multiplication process of (-1,1)*(1/3,-1/2), which results in (-1/2,1/2), and a width of 1/2.
We cannot derive this same width by dividing the widths of x and y, (1/2.5), which results in 2/5.


###2.10###

PROMPT:
------------------------------------------------------------
Exercise 2.10.  Ben Bitdiddle, an expert systems programmer, looks over Alyssa's shoulder and comments that it is not clear what it means to divide by an interval that spans zero. Modify Alyssa's code to check for this condition and to signal an error if it occurs.
------------------------------------------------------------

The problem of dividing by an interval that spans 0 is that an interval describes merely where a number could occur. Thus, the number could in fact be 0.
Our division procedure is allowing a potential division by zero error to procede uninhibited. This should return an undefined, so let's see what that would
look like.

(define (div-interval x y)
  (if (and (>= (upper-bound x) 0) (<= (lower-bound y) 0))
      (error "Division by an interval that spans 0 is undefined:" y)
      (mul-interval x 
		    (make-interval (/ 1.0 (upper-bound y))
				   (/ 1.0 (lower-bound y))))))


(define (add-interval x y)
  (make-interval (+ (lower-bound x) (lower-bound y))
                 (+ (upper-bound x) (upper-bound y))))


(define (mul-interval x y)
  (let ((p1 (* (lower-bound x) (lower-bound y)))
        (p2 (* (lower-bound x) (upper-bound y)))
        (p3 (* (upper-bound x) (lower-bound y)))
        (p4 (* (upper-bound x) (upper-bound y))))
    (make-interval (min p1 p2 p3 p4)
                   (max p1 p2 p3 p4))))

(define (make-interval a b) (cons a b))
(define (lower-bound i)
  (car i))
(define (upper-bound i)
  (cdr i))

(let ((i1 (make-interval 6.12 7.48))
      (i2 (make-interval -4.47 4.94)))
  (div-interval i1 i2))

