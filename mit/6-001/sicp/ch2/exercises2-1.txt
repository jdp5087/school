###2.1###

(define (add-rat x y)
  (make-rat (+ (* (numer x) (denom y))
	       (* (numer y) (denom x)))
	    (* (denom x) (denom y))))
(define (sub-rat x y)
  (made-rat (- (* (numer x) (denom y))
	       (* (numer y) (denom x)))
	    (* (denom x) (denom y))))
(define (mul-rat x y)
  (make-rat (* (numer x) (numer y))
	    (* (denom x) (denom y))))
(define (div-rat x y)
  (make-rat (* (numer x) (denom y))
	    (* (numer y) (denom x))))
(define (equal-rat? x y)
  (= (* (numer x) (denom y))
     (* (numer y) (denom x))))

(define (make-rat n d)
  (let ((g (gcd n d)))
    (cond ((and (negative? n) (negative? d))
	   (cons (/ (abs n) g) (/ (abs d) g)))
	  ((negative? d)
	   (cons (/ (negate n) g) (/ (negate d) g)))
	  (else
	   (cons (/ n g) (/ d g))))))
(define (numer x) (car x))
(define (denom x) (cdr x))
(define (negative? x)
  (< x 0))
(define (negate x)
  (- x))
(define (print-rat x)
  (newline)
  (display (numer x))
  (display "/")
  (display (denom x)))

(print-rat (make-rat -20 -4))
(print-rat (mul-rat (make-rat -20 -8) (make-rat 3 -7)))

###2.2###

(define (make-segment start end)
  (cons start end))
(define (start-segment s)
  (car s))
(define (end-segment s)
  (cdr s))
(define (make-point x y)
  (cons x y))
(define (x-point p)
  (car p))
(define (y-point p)
  (cdr p))
(define (print-point p)
  (newline)
  (display "(")
  (display (x-point p))
  (display ",")
  (display (y-point p))
  (display ")"))
(define (average s f)
  (/ (+ (f (start-segment s))
	(f (end-segment s)))
     2))
(define (midpoint s)
  (make-point (average s x-point)
	      (average s y-point)))

(let ((point1 (make-point 2 4))(point2 (make-point 4 0)))
  (let ((seg (make-segment point1 point2)))
    (print-point (midpoint seg))))


###2.3###

The following code is common to both implementations of rectangle:

(define (make-segment start end)
  (cons start end))
(define (start-segment s)
  (car s))
(define (end-segment s)
  (cdr s))
(define (make-point x y)
  (cons x y))
(define (x-point p)
  (car p))
(define (y-point p)
  (cdr p))
(define (print-point p)
  (newline)
  (display "(")
  (display (x-point p))
  (display ",")
  (display (y-point p))
  (display ")"))
(define (average s f)
  (/ (+ (f (start-segment s))
	(f (end-segment s)))
     2))
(define (midpoint s)
  (make-point (average s x-point)
	      (average s y-point)))
(define (length-segment s)
  (hypotenuse s))
(define (hypotenuse s)
  (sqrt (+ (square (grid-distance s x-point))
	   (square (grid-distance s y-point)))))
(define (grid-distance seg coord)
  (abs (- (coord (end-segment seg))
	  (coord (start-segment seg)))))

@@@PART A@@@

(define (make-rectangle p1 p2 p3 p4)
  (cons (cons p1 p2) (cons p3 p4)))
(define (rect-point1 r)
  (car (car r)))
(define (rect-point2 r)
  (cdr (car r)))
(define (rect-point3 r)
  (car (cdr r)))
(define (rect-point4 r)
  (cdr (cdr r)))
(define (rect-side1 r)
  (make-segment (rect-point1 r) (rect-point2 r)))
(define (rect-side2 r)
  (make-segment (rect-point2 r) (rect-point3 r)))
(define (rect-side3 r)
  (make-segment (rect-point3 r) (rect-point4 r)))
(define (rect-side4 r)
  (make-segment (rect-point4 r) (rect-point1 r)))
(define (rect-length r)
  (length-segment (rect-side1 r)))
(define (rect-width r)
  (length-segment (rect-side2 r)))
(define (rect-perimeter r)
  (* 2 (+ (rect-length r)
	  (rect-width r))))
(define (rect-area r)
  (* (rect-length r)
     (rect-width r)))

(let ((p1 (make-point 0 0))
      (p2 (make-point 4 0))
      (p3 (make-point 4 4))
      (p4 (make-point 0 4)))
  (let ((rect1 (make-rectangle p1 p2 p3 p4)))
    (newline)
    (display "Perimeter: ")
    (display (rect-perimeter rect1))
    (newline)
    (display "Area: ")
    (display (rect-area rect1))))
Perimeter: 16
Area: 16

(let ((p1 (make-point 0 0))
      (p2 (make-point 8 0))
      (p3 (make-point 8 4))
      (p4 (make-point 0 4)))
  (let ((rect1 (make-rectangle p1 p2 p3 p4)))
    (newline)
    (display "Perimeter: ")
    (display (rect-perimeter rect1))
    (newline)
    (display "Area: ")
    (display (rect-area rect1))))
Perimeter: 24
Area: 32

Here's my first implementation of rectangle. There are many ways that rectangle could be designed. This implementation has the
advantage that it would be easily extended (because it is easy to access all of the points and line segments of the rectangle).
The disadvantage is that for the purposes of just getting perimeter and area, it uses a lot of storage, and is relatively costly.

@@@PART B@@@

(define (make-length p1 p2)
  (make-segment p1 (make-point (x-point p2) (y-point p1))))
(define (make-width p1 p2)
  (make-segment p1 (make-point (x-point p1) (y-point p2))))
(define (make-rectangle p1 p2)
  (cons (make-length p1 p2)
	(make-width p1 p2)))
(define (rect-length r)
  (length-segment (car r)))
(define (rect-width r)
  (length-segment (cdr r)))
(define (rect-perimeter r)
  (* 2 (+ (rect-length r)
	  (rect-width r))))
(define (rect-area r)
  (* (rect-length r)
     (rect-width r)))
(let ((p1 (make-point 0 0))
      (p2 (make-point 4 4)))
  (let ((rect1 (make-rectangle p1 p2)))
    (newline)
    (display "Perimeter: ")
    (display (rect-perimeter rect1))
    (newline)
    (display "Area: ")
    (display (rect-area rect1))))
Perimeter: 16
Area: 16

(let ((p1 (make-point 0 0))
      (p2 (make-point 8 4)))
  (let ((rect1 (make-rectangle p1 p2)))
    (newline)
    (display "Perimeter: ")
    (display (rect-perimeter rect1))
    (newline)
    (display "Area: ")
    (display (rect-area rect1))))
Perimeter: 24
Area: 32

Here's my second, much more streamlined implementation. Rectangle only accepts two points as parameters, and figures out the missing points.
It knows this because both length sides will be the same and both width sides will also be the same. Furthermore, this version of
rectangle doesn't store all of the points explicitly. It only stores 2 line segments, 1 for width and 1 for length. The selectors
don't even return a segment, just the length of each respective line. Notice that the implementation of perimeter and area are identical to
PART A, and both functions behave identically, thus we have achieved the goal of abstraction barriers between perimeter, area, and the underlying
data structures.

###2.4###

(define (cons x y)
  (lambda (m) (m x y)))

(define (car m)
  (z (lambda (p q) p)))

***Substitution model***

(car (cons x y))
(car (lambda (m) (m x y)))
(car #[compound-procedure 12])
(#[compound-procedure 12] (lambda (p q) p))
(#[compound-procedure 12] #[compound-procedure 13])
---for the sake of clarity ill write out the lambda procedures)
((lambda (m) (m x y)) (lambda (p q) p))
((lambda (p q) p) x y)
((lambda (x y) x) x y) ;;;<---which is like saying
x

So, the corresponding definition of cdr is as follows:

(define (cdr z)
  (z (lambda (p q) q)))


###2.5###

(define (mod b n)
  (mod-iter b n 0 0))
(define (mod-iter b n r c)
  (if (not (= 0 r))
      (- c 1)
      (mod-iter b (/ n b) (remainder n b) (+ c 1))))
(mod 2 (* (expt 2 4) (expt 3 3)))
(define (cons a b)
  (let ((p (* (expt 2 a) (expt 3 b))))
    (define deliver (lambda (b) (mod b p)))
    deliver))
(define (car m)
  ((lambda (m) (m 2)) m))
(define (cdr m)
  ((lambda (m) (m 3)) m))

(car (cons 4 5))
(cdr (cons 4 5))

It is amazing how well this course fits with 6.042J (which I'm taking in parallel, and for that class I just read a chapter on number theory).

###2.6###

Heres the prompt:

--------------------------------------------------------------------------------
Exercise 2.6.  In case representing pairs as procedures wasn't mind-boggling enough, consider that, in a language that can manipulate procedures, we can get by without numbers (at least insofar as nonnegative integers are concerned) by implementing 0 and the operation of adding 1 as

(define zero (lambda (f) (lambda (x) x)))

(define (add-1 n)
  (lambda (f) (lambda (x) (f ((n f) x)))))

This representation is known as Church numerals, after its inventor, Alonzo Church, the logician who invented the  calculus.

Define one and two directly (not in terms of zero and add-1). (Hint: Use substitution to evaluate (add-1 zero)). Give a direct definition of the addition procedure + (not in terms of repeated application of add-1).
--------------------------------------------------------------------------------

So let's just follow the hint of using the substitution model and see if we can figure out what in the world is going on here.

(add-1 zero)

(add-1 (lambda (f) (lambda (x) x)))
(lambda (f) (lambda (x) (f (((lambda (f) (lambda (x) x)) f) x))))
(lambda (f) (lambda (x) (f ((lambda (x) x)) x))))
(lambda (f) (lambda (x) (f x)))) <<<-----direct definition of one

(add-1 (add-1 zero))
(add-1 (add-1 (lambda (f) (lambda (x) x))))
(add-1 (lambda (f) (lambda (x) (f (((lambda (f) (lambda (x) x)) f x)))))
(add-1 (lambda (f) (lambda (x) (f ((lambda (x) x)) x))))
(add-1 (lambda (f) (lambda (x) (f x))))
(lambda (f) (lambda (x) (f (((lambda (f) (lambda (x) (f x)))) f) x)))
(lambda (f) (lambda (x) (f ((lambda (x) (f x)))) x)))
(lambda (f) (lambda (x) (f (f x)))) <<<-----direct definition of two


(define (+ n1 n2)
  (lambda (f) (lambda (x) ((n1 f) ((n2 f) x))))) <<<-----direct definition of add

(+ (lambda (f) (lambda (x) (f (f x)))) (lambda (f) (lambda (x) (f x)))) ;;; Here I'm adding one and two
(lambda (f) (lambda (x) (((lambda (f) (lambda (x) (f (f x)))) f) (((lambda (f) (lambda (x) (f x))) f) x))))
(lambda (f) (lambda (x) (((lambda (f) (lambda (x) (f (f x)))) f) ((lambda (x) (f x)) x))))
(lambda (f) (lambda (x) (((lambda (f) (lambda (x) (f (f x)))) f) (f x))))
(lambda (f) (lambda (x) ((lambda (x) (f (f x))) (f x))))
(lambda (f) (lambda (x) (f (f (f x)))))

While this has been an eye opening experience, the usefulness here doesn't exactly blow me away. One of the huge aspects of good code is that
it should be readable. I spent 2 or so hours trying to think through all of the twists and contortions that the procedures are doing here.
While it is elegant, the practical use is not apparent to me. When I was trying to read the code, I found that telling myself "Well, this is a procedure, that takes f
and returns a procedure that takes x, which applies f with x substituted in to a composition of n and f" to be entirely confusing and inadequate for
understanding what is going on. While eventually I did grasp the idea here, it wasn't without struggle. perhaps the lesson I learned is to never write code
like this if I plan on having anyone else read it.


###2.7###

PROMPT:
-----------------------------------------------------------------------------------------------------------------
Exercise 2.7.  Alyssa's program is incomplete because she has not specified the implementation of the interval abstraction. Here is a definition of the interval constructor:

(define (make-interval a b) (cons a b))

Define selectors upper-bound and lower-bound to complete the implementation.
-----------------------------------------------------------------------------------------------------------------

(define (add-interval x y)
  (make-interval (+ (lower-bound x) (lower-bound y))
                 (+ (upper-bound x) (upper-bound y))))


(define (mul-interval x y)
  (let ((p1 (* (lower-bound x) (lower-bound y)))
        (p2 (* (lower-bound x) (upper-bound y)))
        (p3 (* (upper-bound x) (lower-bound y)))
        (p4 (* (upper-bound x) (upper-bound y))))
    (make-interval (min p1 p2 p3 p4)
                   (max p1 p2 p3 p4))))

(define (div-interval x y)
  (mul-interval x 
                (make-interval (/ 1.0 (upper-bound y))
                               (/ 1.0 (lower-bound y)))))

(define (make-interval a b) (cons a b))
(define (lower-bound i)
  (car i))
(define (upper-bound i)
  (cdr i))

(let ((i1 (make-interval 6.12 7.48))
      (i2 (make-interval 4.47 4.94)))
  (add-interval i1 i2))

###2.8###

PROMPT:
------------------------------------------------------------
Exercise 2.8.  Using reasoning analogous to Alyssa's, describe how the difference of two intervals may be computed. Define a corresponding subtraction procedure, called sub-interval.
------------------------------------------------------------

(define (sub-interval x y)
  (make-interval (- (lower-bound x) (lower-bound y))
		 (- (upper-bound x) (upper-bound y))))

(let ((i1 (make-interval 6.12 7.48))
      (i2 (make-interval 4.47 4.94)))
  (sub-interval i1 i2))


This procedure simply takes two intervals as arguments and returns a new interval, which has a lower bound of the difference between lower bounds of x and y, and its upper bound is defined as the difference between the upper bounds of x and y.

###2.9###

PROMPT:
------------------------------------------------------------
Exercise 2.9.  The width of an interval is half of the difference between its upper and lower bounds. The width is a measure of the uncertainty of the number specified by the interval. For some arithmetic operations the width of the result of combining two intervals is a function only of the widths of the argument intervals, whereas for others the width of the combination is not a function of the widths of the argument intervals. Show that the width of the sum (or difference) of two intervals is a function only of the widths of the intervals being added (or subtracted). Give examples to show that this is not true for multiplication or division.
------------------------------------------------------------

consider an interval i1 which has upper bound h1 and lower bound l1, and also consider an interval i2 which has upper bound h2 and lower bound l2:

Using the definition of width, we can combine the intervals through addition, and then find their width.

width = (high - low)/2

total_added_width = ((h1+h2)-(l1+l2))/2

Or, we find that we can find the width of i1 and i2, add their widths, and we have the same result:

width1 = (h1-l1)/2
width2 = (h2-l2)/2
combined_added_width = (h1-l1)/2 + (h2-l2)/2 = (h1-l1+h2-l2)/2 = ((h1+h2)-(l1+l2))/2

Now, we can also confirm the same phenomenon with subtraction.

total_subtracted_width = ((h1-h2)-(l1-l2))/2

Now we find each width seperately and combine:

width1 = (h1-l1)/2
width2 = (h2-l2)/2
combinded_subracted_width = (h1-l1)/2 - (h2-l2)/2 = ((h1-l1)-(h2-l2))/2 = (h1-l1-h2+l2)/2 = ((h1-h2)-(l1-l2))/2

so, again, we see that the results are the same.


Ok, so lets consider multiplication of widths by example.

consider the interval (-1,1) and (-2,3)

When we multiply these intervals, we get (-3, 3), which would give a width of 3. This is not the same as multiplying the widths of the original intervals,
which is 1*2.5=2.5

Furthermore, the same intervals demonstrate that we cannot derive the widths through division of the intervals.

The process that divides intervals multiplies x times the reciprocal of y.

So first we take the reciprocal fo y (with upper and lower bound switched), which is (1/3,-1/2).

Then we simply have the multiplication process of (-1,1)*(1/3,-1/2), which results in (-1/2,1/2), and a width of 1/2.
We cannot derive this same width by dividing the widths of x and y, (1/2.5), which results in 2/5.


###2.10###

PROMPT:
------------------------------------------------------------
Exercise 2.10.  Ben Bitdiddle, an expert systems programmer, looks over Alyssa's shoulder and comments that it is not clear what it means to divide by an interval that spans zero. Modify Alyssa's code to check for this condition and to signal an error if it occurs.
------------------------------------------------------------

The problem of dividing by an interval that spans 0 is that an interval describes merely where a number could occur. Thus, the number could in fact be 0.
Our division procedure is allowing a potential division by zero error to procede uninhibited. This should return an undefined, so let's see what that would
look like.

(define (div-interval x y)
  (if (and (>= (upper-bound x) 0) (<= (lower-bound y) 0))
      (error "Division by an interval that spans 0 is undefined:" y)
      (mul-interval x 
		    (make-interval (/ 1.0 (upper-bound y))
				   (/ 1.0 (lower-bound y))))))


(define (add-interval x y)
  (make-interval (+ (lower-bound x) (lower-bound y))
                 (+ (upper-bound x) (upper-bound y))))


(define (mul-interval x y)
  (let ((p1 (* (lower-bound x) (lower-bound y)))
        (p2 (* (lower-bound x) (upper-bound y)))
        (p3 (* (upper-bound x) (lower-bound y)))
        (p4 (* (upper-bound x) (upper-bound y))))
    (make-interval (min p1 p2 p3 p4)
                   (max p1 p2 p3 p4))))

(define (make-interval a b) (cons a b))
(define (lower-bound i)
  (car i))
(define (upper-bound i)
  (cdr i))

(let ((i1 (make-interval 6.12 7.48))
      (i2 (make-interval -4.47 4.94)))
  (div-interval i1 i2))


###2.11###

PROMPT:
------------------------------------------------------------
Exercise 2.11.  In passing, Ben also cryptically comments: "By testing the signs of the endpoints of the intervals, it is possible to break mul-interval into nine cases, only one of which requires more than two multiplications." Rewrite this procedure using Ben's suggestion.
------------------------------------------------------------

There are 16 possible permutations of the signs of the numbers:

++ ++
++ +-
++ --
+- --
+- -+
+- ++
+- +-
++ -+
-+ ++
-+ +-
-+ --
-- --
-- -+
-- ++
-- +-
-+ -+

Of these, only 9 are possible, because 7 have an interval where the upper-bound is less than the lower-bound. Let's explore the multiplications that we need to make.

++ ++ (1,3) (2,4)X
++ -- (2,3) (1,4)X
++ -+ (2,3) (2,4)X
-+ ++ (1,4) (2,4)X
-+ -- (2,3) (1,3)X
-- -- (2,4) (1,3)X
-- -+ (1,4) (1,3)X
-- ++ (1,4) (2,3)X
-+ -+ (1,4)/(2,3) (1,3)/(2,4)X

(the X indicates that I tested each case with the new implementation)

Now we have an idea of how to implement mul-interval:

(define (mul-interval x y)
  (let ((a (lower-bound x))
	(b (upper-bound x))
	(c (lower-bound y))
	(d (upper-bound y)))
    (define (test-mul w x y z comp)
      (if (comp (* w x) (* y z))
	  (* w x)
	  (* y z)))
    (define (interval-by-index w x y z)
      (make-interval (* w x)
		     (* y z)))
    (if (> a 0)
	(if (> c 0)
	    (interval-by-index a c b d) ;;; ++++
	    (if (> d 0)
		(interval-by-index b c b d) ;;; ++-+
		(interval-by-index b c a d))) ;;; ++--
	(if (> b 0)
	    (if (> c 0)
		(interval-by-index a d b d) ;;; -+++
		(if (> d 0)
		    (make-interval (test-mul a d b c <)
				   (test-mul a c b d >)) ;;; -+-+
		    (interval-by-index b c a c))) ;;; -+--
	    (if (> c 0)
		(interval-by-index a d b c) ;;; --++
		(if (> d 0)
		    (interval-by-index a d a c) ;;; ---+
		    (interval-by-index b d a c))))))) ;;; ----

First, I saved each low and high value for both intervals as a b c d. This will reduce the number of times we need to access the selectors,
 and makes the code more readable. Additionally, The nested if structure may appear to be unneccessarily complicated. However, using a cond statement would
require 8 comparisons in the worst case. This implementation only requires 4 in the worst case, in the best case only 2.

###2.12###

PROMPT:
------------------------------------------------------------
Exercise 2.12.  Define a constructor make-center-percent that takes a center and a percentage tolerance and produces the desired interval. You must also define a selector percent that produces the percentage tolerance for a given interval. The center selector is the same as the one shown above.
------------------------------------------------------------

(define (make-center-width c w)
  (make-interval (- c w) (+ c w)))
(define (center i)
  (/ (+ (lower-bound i) (upper-bound i)) 2))
(define (width i)
  (/ (- (upper-bound i) (lower-bound i)) 2))


(define (make-center-percent center tolerance)
  (make-interval (- center (* center (/ tolerance 100)))
		 (+ center (* center (/ tolerance 100)))))
(define (percent i)
  (* (/ (width i) (center i)) 100))

(make-center-percent 10 10)
;Value 16: (9 . 11)

(percent (make-center-percent 10 10))
;Value: 10

###2.13###

PROMPT:
------------------------------------------------------------
Exercise 2.13.  Show that under the assumption of small percentage tolerances there is a simple formula for the approximate percentage tolerance of the product of two intervals in terms of the tolerances of the factors. You may simplify the problem by assuming that all numbers are positive.
------------------------------------------------------------

The resistance of the new interval can be described by:

Wp = (1/((1/W1)+(1/W2)))

and the new center point can be calculated by:

Cp = ((C1*C2)/2)*Wp

since center = width/resistance, we have:

Wp/Rp = ((C1*C2)/2)*Wp

Rp = 1/((C1*c2)/2)

and therefore:

Rp = 2/(C1*C2)

We can also describe this by

Rp = 2/((W1*W2)/(R1/R2)) 

Based on the information we start with, we can now find the resistance of two circuits in parallel in two ways.
I found this answer in a rather circuitous manner, so the mathematical argument might not be exactly linear, but it works.

Here's an implementation using the centers of two intervals

(define (par-res i j)
  (* 100 (/ 2 (* (center i) (center j)))))

(let ((i (make-center-percent 6.8 10))
      (j (make-center-percent 4.7 5)))
  (par-res i j))
;Value: 6.25782227784731

###2.14###
PROMPT:
------------------------------------------------------------
Exercise 2.14.  Demonstrate that Lem is right. Investigate the behavior of the system on a variety of arithmetic expressions. Make some intervals A and B, and use them in computing the expressions A/A and A/B. You will get the most insight by using intervals whose width is a small percentage of the center value. Examine the results of the computation in center-percent form (see exercise 2.12).
------------------------------------------------------------

(let ((a (make-center-percent 30 0.01))
      (b (make-center-percent 20 0.01))
      (one (make-interval 1 1)))
  (display "center :")
  (display (center (mul-interval a b)))
  (newline)
  (display "percent:")
  (display (percent (mul-interval a b)))
  (newline)
  (display "center :")
  (display (center (add-interval a b)))
  (newline)
  (display "percent:")
  (display (percent (add-interval a b)))
  (newline)
  (display "center :")
  (display (center (add-interval (div-interval one a) (div-interval one b))))
  (newline)
  (display "percent:")
  (display (percent (add-interval (div-interval one a) (div-interval one b))))
  (newline)
  (display "center :")
  (display (center (par1 a b)))
  (newline)
  (display "percent:")
  (display (percent (par1 a b)))
  (newline)  (display "center :")
  (display (center (par2 a b)))
  (newline)
  (display "percent:")
  (display (percent (par2 a b)))
  (newline)
  (let ((d (add-interval a b))
	(c (mul-interval a b)))
    (let ((e (make-interval (/ 1 (upper-bound d)) (/ 1 (lower-bound d)))))
    (display "center :")
    (display (center (make-interval (/ 1 (upper-bound d)) (/ 1 (lower-bound d)))))
    (newline)
    (display "percent:")
    (display (percent (make-interval (/ 1 (upper-bound d)) (/ 1 (lower-bound d)))))    
    (newline)
    (display "center :")
    (display (center (mul-interval c e)))
    (newline)
    (display "percent:")
    (display (percent (mul-interval c e)))
    (newline)
    (display "center :")
    (newline)
    (display "percent:")
    (newline)
    (display "center :")
    (newline)
    (display "percent:")
    (newline)))))

It appears as though every time an interval is multiplied by another interval that is not one, the percentage resistance increases. This is the case even when an
interval is multiplied by an inverse. 

center :600.000006
percent:.01999999980000076
;;; notice here that (mul-interval a b) results in an increase in the percent tolerance
center :50.
percent:9.999999999990905e-3
center :.08333333416666668
percent:1.0000000000002236e-2
;;; while dividing the interval one by any resistance leaves the percentage intact
center :12.000000480000004
percent:.02999999919999527
center :12.
percent:1.0000000000006299e-2
center :.0200000002
percent:9.999999999990789e-3
;;; This is the inverse of (add-interval a b), which has a percentage that reflects the original percentage
center :12.000000480000004
percent:.02999999919999527
;;; however, multiplying the results of (mul-interval a b) and the inverse of (add-interval a b) increases the percentage tolerance yet again.

I dare to speculate that rounding errors have something to do with it. In the first formula, we multiply the two intervals and then divide by the sum of the same
intervals. This leads to the numbers going through significant alterations in its value, and then dividing a relatively large value by a very small one (inverse).
Small rounding errors will result in a significant loss of fidelity in the end result.

In the second formula, the values are relatively resililient, becuase dividing the "one" interval by our values mantains fidelity to our end value throughout the
calculation (the percentage resistance is not changed just to revert back to its original value again).

###2.15###
PROMPT:
------------------------------------------------------------
Exercise 2.15.  Eva Lu Ator, another user, has also noticed the different intervals computed by different but algebraically equivalent expressions. She says that a formula to compute with intervals using Alyssa's system will produce tighter error bounds if it can be written in such a form that no variable that represents an uncertain number is repeated. Thus, she says, par2 is a ``better'' program for parallel resistances than par1. Is she right? Why?
------------------------------------------------------------

My answer to the previous question showed that indeed, par2 leads to tigther error bounds than par1. The reason for this is because when we calculate par1, we are using the formula (R1R2/R1+R2). This leads to two uncertain intermediate variables (a product and a sum) which are then divided. While addition does not change the percentage tolerance of an interval, multiplication does. Therefore, multiplication of two uncertain intervals increases the uncertainty. So, we are multiplying by two uncertain variables twice in this calculation, because division is just multiplication by an inverse.

In par2, division is used three times. However, this calculation is slightly different, because we are dividing an interval with no uncertainty (because it is an interval that ranges between 1 and 1). Thus, multiplication of an an interval without uncertainty by the inverse of an interval with uncertainty will not increase the percentage tolerance. In other words, the percentage tolerance will be the same as the inverse of the uncertain interval. This means that for calculating tighter bounds, Eva Lu Ator is correct.

###2.16###
------------------------------------------------------------
Exercise 2.16.  Explain, in general, why equivalent algebraic expressions may lead to different answers. Can you devise an interval-arithmetic package that does not have this shortcoming, or is this task impossible? (Warning: This problem is very difficult.)
------------------------------------------------------------

In the interest of forward progress (and due to the fact that I have very limited time), I'm going to just take a jab at the first part of the question and move on.

I'd say that there are two possible reasons. The first is due to the nature of how numbers are stored in computers. Rounding errors can occur with very small or very large numbers that contain a large number of significant digits. When we are dealing with very small intervals, a number that is stored in IEEE floating point format only allocates 23 bits to store the mantissa of a number (because the other 1 bit indicates whether a number is positive or negative, and 8 bits store the exponent of the number). With very small intervals, every missing significant digit will have an impact on the final outcome of the calculation. Every number that requires rounding will reduce the precision of the end result. Every missing 1/10000th will have an impact when the number is multiplied several times.

The first reason is probably not as significant as the second, which relates to the implementation of a formala. Algebra represents an ideal, and symbolic way to manipulate variables. The last question already hinted at this phenomenon. Since the second equation implemented an interval without uncertainty (the one defined in the let statement), the equation ultimatetely had more fidelity to the outcome resistance than par1. Furthermore, algebra does not assume a layer of abstraction in its governing rules. For instance, the algebraic equation ((R1R2)/(R1+R2)) is equivalent to (1/((1/R1)+(1/r2))), but that is when the variables represent integers or real numbers. It has no way to account for the fact that R1 and R2 actually represent a range of numbers. That is why par2, which uses the interval "one", is more accurate, because an interval with no uncertainty behaves more like an integer or a real number.

NOTE: Curiosity got the best of me, so I looked up the answer to the second part of this question. Apparently, the answer is that a package cannot be developed. And the reason is that repeating an uncertain variable in a calculation results in an implementation that cannot be the same accross equivalent algebraic equations. If the repetition of uncertain variables can be avoided, then a system could be implemented, but in the case of interval arithmetic, that is not possible.




