###1.1###

10

;; 10


(+ 5 3 4)

;; 12

(- 9 1)

;; 8

(/ 6 2)

;; 3

(+ (* 2 4) (- 4 6))

;; 6

(define a 3)

;; a

(define b (+ a 1))

;; b

(+ a b (* a b))

;; 19

(= a b)

;; #f

(if (and (> b a) (< b (* a b)))
    b
    a)

;; 4

(cond ((= a 4) 6)
      ((= b 4) (+ 6 7 a))
      (else 25))

;; 16

(+ 2 (if (> b a) b a))

;; 6

(* (cond ((> a b) a)
         ((< a b) b)
         (else -1))
   (+ a 1))


;; 16



###1.2###

(/ (+ 5
      4
      (- 2
	 (- 3
	    (+ 6
	       (/ 1 5)))))
   (* 3
      (- 6 2)
      (- 2 7)))
;Value: -71/300


###1.3###

(define (sum-greater x y z)
  (cond ((and (> x z) (> y z)) (+ x y))
	((and (> x y) (> z y)) (+ x z))
	(else (+ y z))))
;Value: sum-greater

(sum-greater 1 2 3)
;Value: 5

(sum-greater 3 2 1)
;Value: 5

(sum-greater 2 1 3)
;Value: 5


###1.4###

The procedure applies the if procedure first. This uses the conditional to determine
whether b is positive or negative. If positive, it adds a and b. if b is negative, it
subtracts b from a.

###1.5###

in applicitave order, the following will occur:

(test 0 (p))

will look up the test procedure:

(if (= 0 0)
   0
  (p))

which will evaluate the predicate, and then decide to evalute the consequent expression.

The consequent expression is 0, so the result will be 0.

In normal order, the following takes place:

(test 0 (p))

will look up the procedure test:

(if (= 0 0)
   0
  (p))

and will attempt to replace operand expressions until only primitive procedures are
obtained.

This will lead to an infinite recursive call to (p).

###1.6###

Substitutive model:

(sqrt 2)

(sqrt-iter 1.0 2)

;;; calls new-if

(new-if (good-enough? 1.0 2)
    1.0
    (sqrt-iter (improve 1.0 2)
               x)))

;;; all combinations must be solved before they are handed to new if

;;;good enough combination

;;; The problem lies in the fact that all combinations are evaluated before the are applied as arguments. The function behaves as normal until
;;; we reach the point where good-enough? evaluates to true. At this point, instead of the special form of if which would only evaluate the true
;;; expression, the new-if function evaluates the sqrt-iter function once again before it applies the arguments, which will lead to an infinite loop.

;;; confirmed through experimentation, the interpreter aborts due to maximum recursion depth being exceeded.

###1.7###

;;;The problem is that this test is not precise enough for small number. The algorithm will halt when the difference between x and guess**2 are within
;;;0.001 of each other. This level of precision is inadequate for values of say, 0.00001. Here, the program has precision several orders of
;;;magnitude less precise than the value we are looking for, so any answer will be useless.

;;;Additionally, very large numbers are stored (I think) in IEEE floating-point format. In these numbers, the mantissa stores numbers from
;;;left to right, meaning that if the length of the binary number exceeds the allotted bits (say 23) then the number will start throwing away
;;;precision on the end. Thus, a value of 0.001 will probably be meaningless as a "good-enough" evaluator at extremely large values.

(define (new-good-enough? guess old-guess)
  (< (/ (abs (- guess old-guess))
	old-guess)
     0.001))

;;; This is my solution, which just takes a percentage change with respect to the old-guess. This will be more precise for small values, because a
;;; very large denominator will output very small results even when the precision of the square root calculation is not very small. For instance

;;; 1 billion - 1 billion and 1 \ 1 billion will satisfy this condition, but our precision has not increased beyond the tens column yet.


###1.8###

(define (improve guess x)
  (/ (+ (/ x
	   (square guess))
	(* 2 guess))
     3))

(define (cbrt-good-enough? guess old-guess)
  (< (/ (abs (- guess old-guess))
	old-guess)
     0.001))


(define (cbrt-iter guess old-guess x)
  (if (cbrt-good-enough? guess old-guess)
      guess
      (cbrt-iter (improve guess x)
		 guess
		 x)))

(define (cbrt x)
  (cbrt-iter 1.0 0.001 x))

(cbrt 27)
;Value: 3.0000005410641766

"this is a string"

(display "this is a string")

(string-length "woo")

(string=? "woo" "wo")