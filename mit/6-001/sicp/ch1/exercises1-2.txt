###1.9###

The first procedure definition describes a linear recursive process:

(define (+ a b)
   (if (= a 0)
   b
   (inc (+ (dec a) b))))

(+ 4 5)
(inc (+ 3 5))
(inc (inc (+ 2 5)))
(inc (inc (inc (+ 1 5))))
(inc (inc (inc (inc (+ 0 5)))))
(inc (inc (inc (inc 5))))
(inc (inc (inc 6)))
(inc (inc 7))
(inc 8)
9

the second procedure describes a linear iterative process

(define (+ a b)
   (if (= a 0)
   b
   (+ (dec a) (inc b))))

(+ 4 5)
(+ 3 6)
(+ 2 7)
(+ 1 8)
(+ 0 9)
9

###1.10###

(define (A x y)
  (cond ((= y 0) 0)
        ((= x 0) (* 2 y))
        ((= y 1) 2)
        (else (A (- x 1)
                 (A x (- y 1))))))
(A 1 10)
(A 0
   (A 1 9))
(A 0
   (A 0
      (A 1 8)))
(A 0
   (A 0
      (A 0
	 (A 1 7))))
;;; until...
(A 0
   (A 0
      (A 0
	 (A 0
	    (A 0
	       (A 0
		  (A 0
		     (A 0
			(A 0
			   (A 1 1))))))))))
;;; which returns 2
;;; this doubles 2 9 times (which is 2^10)
;;; this evaluates to 1024

(A 2 4)
(A 1
   (A 2 3))
(A 1
   (A 1
      (A 2 2)))
(A 1
   (A 1
      (A 1
	 (A 2 1))))
;;; This returns 2
(A 1
   (A 1
      (A 1
	 2)))
(A 1
   (A 1
      (A 0
	 (A 1 1))))
(A 1
   (A 1
      (A 0
	 2)))
(A 1
   (A 1
      4))
(A 1
   (A 0
      (A 1 3)))
;;; ...until

(A 1
   (A 0
      (A 0
	 (A 0 1))))
; which is 2^4

(A 1 16)
;;; which is 2^16
;;; that results in 65536


(A 3 3)
(A 2
   (A 3 2))
(A 2
   (A 2
      (A 3 1)))
(A 2
   (A 2
      2))
(A 2
   (A 2
      2))
(A 2
   (A 1
      (A 2 1)))
(A 2
   (A 1
      2))
(A 2
   (A 0
      (A 1 1)))
(A 2
   (A 0
      2))
(A 2
   4)
;;; which we know returns 65536

f = 2n

g(n) = 2^n where n >= 1
g(1) = 0

I had to look up the answer for this last one. The reason that I was having trouble is because I was looking for a clean mathematical formula instead of a
recursive functional definition.

Here's what I did manage to notice.

I noticed that the pattern was:

n    h(n)     which is:
0    0        ?
1    2        2
2    4        2^2
3    16       2^4
4    65536    2^16

so I knew that the exponent was growing exponentially, but there isn't a way to express this without a piecewise function that I could think of, so I got stuck.

Here's the actual function definition.

h(0) = 0
h(1) = 2
h(n) where n > 1 = 2^(h(n-1))

so then we have:

h(2) = 2^2
h(3) = 2^(2^2)
h(4) = 2^(2^(2^2))

###1.11###

;;; linear recursive process

(define (f n)
  (if (< n 3)
      n
      (+
       (f (- n 1))
       (* 2 (f (- n 2)))
       (* 3 (f (- n 3))))))

;;; linear iterative process

(define (g-iter x y z count n)
  (cond ((< n 3) n)
	((< count 3) x)
	(else (g-iter (+ x (* 2 y) (* 3 z))
		      x
		      y
		      (- count 1)
		      n))))

(define (g n)
  (g-iter 2 1 0 n n))


###1.12###


(define (pascal row column)
   (cond ((or (= column row) (= 1 column)) 1)
	 (else (+ (pascal (- row 1) (- column 1))
		  (pascal (- row 1) column)))))

(pascal 4 3)

###1.13###

Will fill in later when I figure out LaTeX.

###1.14###

Drawing on paper. It appears that the growth in use of space is linear (each node only needs to know about the nodes above it).
The growth in time is 2^n. This is by far an upper bound, because many of the branches don't propogate full binary trees,
however the growth still exceeds n2 for greater values of n. (count-change 1000) didn't return an answer within 1 minute before
I aborted the process.

;;; WRONG HERE! I was correct the the space used is linear, but the number of steps is actually BigO(n^5). The lowest denomination results in a tree that is
2n +1. Then, each layer of denomination after that leads to (n/k)*(complexity of k-1 layer), so k = 2 would have (n/5)*(2n - 1), which is BigO(n^2). For
k=3 we have (n/10)*(n^2) so BigO(n^3). For k=5 we have BigO(n^5). This answer wasn't at all obvious to me. Bill the Lizard, who had two courses in analysis of
algorithms posted their answer online. I think that working through CLRS will provide the necessary background in analyzing complexity of algorithms.

###1.15###

a.)

Let's just write it out using the substitutive model (see the file 1-15.scm).

We end up with before the delayed calls to p unravel:

(p (p (p (p (p 0.05)))))

So, we call p 5 times when the we start with (sine 12.05).

b.)

The number of calls to sine is equavalent can be expressed as k. the relationship between k and n is

(n/(3^k)) <= 0.1

In other words, it takes k calls to sine for n to be less than 0.1. We will always have 1 extra
call to sine in order to have the base case returned. The number of operations from p will always be 4
Thus, the actual number of calls is to sine 4*log3(n) +1. Thus, our magnitude is BigO(log3(n))

The use of space is also related to the number of calls to sine. Therefore the use of space is also (BigO(log3(n)).


###1.16###

(define square
  (lambda (x)
    (* x x)))

(define remainder
  (lambda (n d)
    (/ n d)))

(define even?
  (lambda (n)
    (= (remainder n 2.0) 0)))

(define fast-exp
  (lambda (b n)
    (fast-exp-iter b n 1)))

(define fast-exp-iter
  (lambda (b n a)
    (if (< n 1)
	a
	(if (even? n)
	    (fast-exp-iter b (/ n 2) (* a (square b)))
	    (fast-exp-iter b (- n 1) (* a b))))))

(fast-exp 2 16)
;Value: 65536

(fast-exp 2 17)
;Value: 131072

###1.17###




