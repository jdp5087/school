###1.9###

The first procedure definition describes a linear recursive process:

(define (+ a b)
   (if (= a 0)
   b
   (inc (+ (dec a) b))))

(+ 4 5)
(inc (+ 3 5))
(inc (inc (+ 2 5)))
(inc (inc (inc (+ 1 5))))
(inc (inc (inc (inc (+ 0 5)))))
(inc (inc (inc (inc 5))))
(inc (inc (inc 6)))
(inc (inc 7))
(inc 8)
9

the second procedure describes a linear iterative process

(define (+ a b)
   (if (= a 0)
   b
   (+ (dec a) (inc b))))

(+ 4 5)
(+ 3 6)
(+ 2 7)
(+ 1 8)
(+ 0 9)
9

###1.10###

(define (A x y)
  (cond ((= y 0) 0)
        ((= x 0) (* 2 y))
        ((= y 1) 2)
        (else (A (- x 1)
                 (A x (- y 1))))))
(A 1 10)
(A 0
   (A 1 9))
(A 0
   (A 0
      (A 1 8)))
(A 0
   (A 0
      (A 0
	 (A 1 7))))
;;; until...
(A 0
   (A 0
      (A 0
	 (A 0
	    (A 0
	       (A 0
		  (A 0
		     (A 0
			(A 0
			   (A 1 1))))))))))
;;; which returns 2
;;; this doubles 2 9 times (which is 2^10)
;;; this evaluates to 1024

(A 2 4)
(A 1
   (A 2 3))
(A 1
   (A 1
      (A 2 2)))
(A 1
   (A 1
      (A 1
	 (A 2 1))))
;;; This returns 2
(A 1
   (A 1
      (A 1
	 2)))
(A 1
   (A 1
      (A 0
	 (A 1 1))))
(A 1
   (A 1
      (A 0
	 2)))
(A 1
   (A 1
      4))
(A 1
   (A 0
      (A 1 3)))
;;; ...until

(A 1
   (A 0
      (A 0
	 (A 0 1))))
; which is 2^4

(A 1 16)
;;; which is 2^16
;;; that results in 65536


(A 3 3)
(A 2
   (A 3 2))
(A 2
   (A 2
      (A 3 1)))
(A 2
   (A 2
      2))
(A 2
   (A 2
      2))
(A 2
   (A 1
      (A 2 1)))
(A 2
   (A 1
      2))
(A 2
   (A 0
      (A 1 1)))
(A 2
   (A 0
      2))
(A 2
   4)
;;; which we know returns 65536

f = 2n

g(n) = 2^n where n >= 1
g(1) = 0

I had to look up the answer for this last one. The reason that I was having trouble is because I was looking for a clean mathematical formula instead of a
recursive functional definition.

Here's what I did manage to notice.

I noticed that the pattern was:

n    h(n)     which is:
0    0        ?
1    2        2
2    4        2^2
3    16       2^4
4    65536    2^16

so I knew that the exponent was growing exponentially, but there isn't a way to express this without a piecewise function that I could think of, so I
got stuck.

Here's the actual function definition.

h(0) = 0
h(1) = 2
h(n) where n > 1 = 2^(h(n-1))

so then we have:

h(2) = 2^2
h(3) = 2^(2^2)
h(4) = 2^(2^(2^2))

###1.11###

;;; linear recursive process

(define (f n)
  (if (< n 3)
      n
      (+
       (f (- n 1))
       (* 2 (f (- n 2)))
       (* 3 (f (- n 3))))))

;;; linear iterative process

(define (g-iter x y z count n)
  (cond ((< n 3) n)
	((< count 3) x)
	(else (g-iter (+ x (* 2 y) (* 3 z))
		      x
		      y
		      (- count 1)
		      n))))

(define (g n)
  (g-iter 2 1 0 n n))


###1.12###




